<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Suno Multitrack Player - amaaåv</title>
  <link rel="icon" href="../favicon.ico" type="image/x-icon">
  <meta name="description" content="Multi-track audio player for Suno-generated music with individual track controls and waveform visualization">
  <meta name="keywords" content="audio, multitrack, player, Suno, music, waveform, controls">
  <meta name="author" content="amaaov">
  <link rel="canonical" href="https://amaaov.github.io/pages/20250821113700_suno_multitrack_example.html">
  <meta property="og:title" content="Suno Multitrack Player - amaaåv">
  <meta property="og:description" content="Multi-track audio player for Suno-generated music">
  <meta property="og:image" content="https://amaaov.github.io/index.jpeg">
  <meta property="og:url" content="https://amaaov.github.io/pages/20250821113700_suno_multitrack_example.html">
  <meta property="og:type" content="article">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Suno Multitrack Player - amaaåv">
  <meta name="twitter:description" content="Multi-track audio player for Suno-generated music">
  <meta name="twitter:image" content="https://amaaov.github.io/index.jpeg">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

        body {
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, sans-serif;
      line-height: 1.6;
      color: #f8f9fa;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 25%, #16213e 50%, #0f3460 75%, #533483 100%);
      min-height: 100vh;
      overflow-x: hidden;
      font-feature-settings: "kern" 1, "liga" 1, "calt" 1;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

        .container {
      max-width: 1200px;
      margin: 40px auto;
      padding: 60px 40px;
      background: rgba(255, 255, 255, 0.02);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-radius: 24px;
      position: relative;
    }

    .container::before {
      content: '';
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.03) 0%, transparent 50%, rgba(255, 255, 255, 0.01) 100%);
      border-radius: 24px;
      pointer-events: none;
    }

    header {
      text-align: center;
      margin-bottom: 60px;
      padding: 40px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      position: relative;
    }

    h1 {
      font-size: 3.2rem;
      font-weight: 800;
      color: #ffffff;
      margin-bottom: 20px;
      background: linear-gradient(135deg, #64ffda, #00d4ff, #ff6b9d);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      letter-spacing: -0.03em;
      text-shadow: 0 0 30px rgba(100, 255, 218, 0.3);
      line-height: 1.1;
    }

    .subtitle {
      font-size: 1.25rem;
      color: rgba(255, 255, 255, 0.75);
      font-weight: 400;
      letter-spacing: 0.01em;
      line-height: 1.4;
      max-width: 600px;
      margin: 0 auto;
    }

        .song-selector {
      background: rgba(255, 255, 255, 0.01);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      padding: 30px;
      border-radius: 20px;
      margin-bottom: 40px;
      text-align: center;
    }

    .song-selector h3 {
      color: #64ffda;
      margin-bottom: 20px;
      font-size: 1.2rem;
      font-weight: 600;
    }

    .song-buttons {
      display: flex;
      gap: 15px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .song-btn {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.8);
      padding: 12px 24px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 500;
      font-size: 0.95rem;
    }

    .song-btn:hover {
      background: rgba(100, 255, 218, 0.1);
      border-color: rgba(100, 255, 218, 0.3);
      color: #64ffda;
    }

    .song-btn.active {
      background: rgba(100, 255, 218, 0.15);
      border-color: #64ffda;
      color: #64ffda;
    }

        .player-controls {
      background: rgba(255, 255, 255, 0.01);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      padding: 30px;
      border-radius: 20px;
      margin-bottom: 40px;
      text-align: center;
    }

    .control-buttons {
      display: flex;
      gap: 15px;
      justify-content: center;
      margin-bottom: 25px;
    }

        .control-btn {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.8);
      padding: 15px 25px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 500;
      font-size: 1rem;
      min-width: 80px;
    }

    .control-btn:hover {
      background: rgba(100, 255, 218, 0.1);
      border-color: rgba(100, 255, 218, 0.3);
      color: #64ffda;
    }

    .control-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .control-btn:disabled:hover {
      background: rgba(100, 255, 255, 0.1);
      transform: none;
      box-shadow: none;
    }

    .control-btn:active {
      transform: scale(0.98);
    }

    .control-btn.play {
      background: rgba(100, 255, 218, 0.1);
      border-color: rgba(100, 255, 218, 0.3);
      color: #64ffda;
    }

    .control-btn.play:hover {
      background: rgba(100, 255, 218, 0.2);
    }

    .control-btn.audio-ready {
      background: rgba(100, 255, 218, 0.3);
      border-color: rgba(100, 255, 218, 0.7);
      box-shadow: 0 0 10px rgba(100, 255, 218, 0.3);
    }

        .progress-container {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 25px;
    }

    .time-display {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.7);
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }

        .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #64ffda, #00d4ff);
      border-radius: 4px;
      width: 0%;
      transition: width 0.1s ease;
    }

    .progress-handle {
      width: 16px;
      height: 16px;
      background: #64ffda;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(100, 255, 218, 0.5);
      margin-left: auto;
      margin-right: auto;
    }

    .master-volume {
      display: flex;
      align-items: center;
      gap: 15px;
      justify-content: center;
    }

    .volume-label {
      color: rgba(255, 255, 255, 0.8);
      font-weight: 500;
      font-size: 0.95rem;
    }

    .volume-slider {
      width: 150px;
      height: 6px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      outline: none;
      cursor: pointer;
    }

    .volume-slider::-webkit-slider-thumb {
      appearance: none;
      width: 18px;
      height: 18px;
      background: #64ffda;
      border-radius: 2px;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(100, 255, 218, 0.5);
    }

    .volume-slider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: #64ffda;
      border-radius: 2px;
      cursor: pointer;
      border: none;
      box-shadow: 0 0 10px rgba(100, 255, 218, 0.5);
    }

        .tracks-container {
      background: rgba(255, 255, 255, 0.01);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      padding: 30px;
      border-radius: 20px;
    }



        .track {
      display: grid;
      grid-template-columns: 100px 1fr 120px;
      gap: 20px;
      padding: 20px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 16px;
      margin-bottom: 15px;
      transition: all 0.2s ease;
      border: 1px solid rgba(255, 255, 255, 0.05);
      align-items: center;
    }

    .track:hover {
      background: rgba(255, 255, 255, 0.04);
      border-color: rgba(255, 255, 255, 0.1);
    }

          .track-meta {
        display: flex;
        flex-direction: column;
        gap: 4px;
        align-items: flex-start;
        padding: 0;
        margin: 0;
      }

      .track-info {
        display: flex;
        flex-direction: column;
        gap: 5px;
      }

      .track-name {
        font-weight: 600;
        color: rgba(255, 255, 255, 0.9);
        font-size: 1rem;
      }

      .track-duration {
        font-size: 0.8rem;
        color: rgba(255, 255, 255, 0.5);
      }

      .track-icon {
        width: 50px;
        height: 50px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        color: rgba(255, 255, 255, 0.8);
      }

    .track-icon.vocals { background: rgba(255, 105, 180, 0.2); color: #ff69b4; }
    .track-icon.drums { background: rgba(76, 175, 80, 0.2); color: #4caf50; }
    .track-icon.bass { background: rgba(255, 152, 0, 0.2); color: #ff9800; }
    .track-icon.synth { background: rgba(33, 150, 243, 0.2); color: #2196f3; }

    .track-waveform {
      position: relative;
      height: 60px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      cursor: pointer;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Placeholder loading waveform */
    .placeholder-waveform {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 15;
      background: rgba(0, 0, 0, 0.4);
      border-radius: 8px;
      /* Hidden by default, will be shown by JavaScript when needed */
      display: none;
    }

    .placeholder-bars {
      display: flex;
      align-items: flex-end;
      gap: 2px;
      height: 40px;
      margin-bottom: 8px;
    }

    .placeholder-bar {
      width: 3px;
      background: linear-gradient(to top, #64ffda, rgba(100, 255, 218, 0.6));
      border-radius: 2px;
      animation: placeholderPulse 1.5s ease-in-out infinite;
    }

    @keyframes placeholderPulse {
      0%, 100% { opacity: 0.3; transform: scaleY(0.8); }
      50% { opacity: 1; transform: scaleY(1.2); }
    }

    .placeholder-text {
      color: rgba(100, 255, 218, 0.8);
      font-size: 0.8rem;
      font-weight: 500;
      text-align: center;
    }

    /* Loading overlay styling */
    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 20;
      border-radius: 8px;
    }

    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(100, 255, 218, 0.3);
      border-top: 3px solid #64ffda;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 15px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .loading-text {
      color: #64ffda;
      font-size: 0.9rem;
      font-weight: 500;
      margin-bottom: 15px;
    }

    .loading-progress {
      width: 80%;
      text-align: center;
    }

    .loading-progress .progress-bar {
      width: 100%;
      height: 6px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      overflow: hidden;
      margin-bottom: 8px;
    }

    .loading-progress .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #64ffda, #64ffda);
      border-radius: 3px;
      width: 0%;
      transition: width 0.3s ease;
    }

    .progress-text {
      color: rgba(255, 255, 255, 0.8);
      font-size: 0.8rem;
      font-family: monospace;
    }

    .waveform-canvas {
      width: 100%;
      height: 100%;
      cursor: pointer;
      position: absolute;
      top: 0;
      left: 0;
    }

    .playhead {
      position: absolute;
      top: 0;
      left: 0%;
      width: 2px;
      height: 100%;
      background: #64ffda;
      pointer-events: none;
      z-index: 10;
      box-shadow: 0 0 8px rgba(100, 255, 218, 0.8);
    }

    .track-controls {
      display: flex;
      flex-direction: column;
      gap: 4px;
      align-items: center;
    }

    .download-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 20;
      border-radius: 8px;
    }

    .track-download-btn {
      background: #4CAF50;
      border: 1px solid #45a049;
      color: #fff;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      font-weight: bold;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      transition: all 0.2s ease;
    }

    .track-download-btn:hover {
      background: #45a049;
      border-color: #64ffda;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
    }

    .track-download-btn.downloading {
      background: #ff9800;
      border-color: #f57c00;
      cursor: not-allowed;
    }

    .track-download-btn.downloaded {
      background: #2196F3;
      border-color: #1976D2;
      cursor: default;
    }

    .download-icon {
      font-size: 16px;
    }

    .download-text {
      font-size: 10px;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
      justify-content: center;
      align-items: center;
    }

    .button-row {
      display: flex;
      gap: 4px;
      justify-content: center;
    }

    .track-btn {
      width: 24px;
      height: 24px;
      border-radius: 2px;
      border: 1px solid #555;
      background: #333;
      color: #fff;
      cursor: pointer;
      transition: all 0.1s ease;
      font-size: 10px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .track-btn:hover {
      background: #555;
      border-color: #777;
    }

    .track-btn.active {
      background: #0066ff;
      border-color: #0066ff;
      color: #fff;
    }

    .track-btn.muted {
      background: #cc0000;
      border-color: #cc0000;
      color: #fff;
    }

    .track-volume {
      width: 60px;
      height: 6px;
      background: #333;
      border-radius: 0;
      outline: none;
      cursor: pointer;
      border: 1px solid #555;
      position: relative;
    }

    /* Add sticky position indicators for track volume sliders */
    .track-volume::before {
      content: '';
      position: absolute;
      top: -2px;
      left: 0;
      right: 0;
      height: 10px;
      background: repeating-linear-gradient(
        to right,
        transparent,
        transparent calc(25% - 1px),
        rgba(255, 255, 255, 0.2) calc(25% - 1px),
        rgba(255, 255, 255, 0.2) calc(25% + 1px),
        transparent calc(25% + 1px)
      );
      pointer-events: none;
      z-index: 1;
    }

    .track-volume::-webkit-slider-thumb {
      appearance: none;
      width: 12px;
      height: 12px;
      background: #fff;
      border-radius: 0;
      cursor: pointer;
      border: 1px solid #555;
    }

    .track-volume::-moz-range-thumb {
      width: 12px;
      height: 12px;
      background: #fff;
      border-radius: 0;
      cursor: pointer;
      border: 1px solid #555;
    }

    /* Disabled state styling */
    .track-btn:disabled,
    .track-volume:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .track-btn:disabled:hover {
      background: rgba(100, 255, 218, 0.1);
      transform: none;
    }

    .track-info {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .track-name {
      font-weight: 600;
      color: rgba(255, 255, 255, 0.9);
      font-size: 1rem;
    }

    .download-status {
      font-size: 0.8rem;
      color: rgba(255, 255, 255, 0.5);
      font-style: italic;
    }

    .track-duration {
      font-size: 0.8rem;
      color: rgba(255, 255, 255, 0.5);
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: rgba(255, 255, 255, 0.7);
    }

    .error {
      text-align: center;
      padding: 40px;
      color: #ff6b6b;
      background: rgba(255, 107, 107, 0.1);
      border-radius: 12px;
      margin: 20px 0;
    }

    @media (max-width: 768px) {
      .container {
        margin: 20px 10px;
        padding: 40px 25px;
      }

      h1 {
        font-size: 2.4rem;
      }



      .track {
        grid-template-columns: 80px 1fr 110px;
        gap: 15px;
        padding: 15px;
      }

      .track-icon {
        width: 32px;
        height: 32px;
        font-size: 18px;
      }

      /* Make track-meta more compact on mobile */
      .track-meta {
        gap: 2px;
        align-items: center;
      }

      /* Hide track info on mobile */
      .track-info {
        display: none;
      }

      .control-buttons {
        flex-wrap: wrap;
        gap: 10px;
      }

      .control-btn {
        padding: 12px 20px;
        font-size: 0.9rem;
        min-width: 70px;
      }

      .song-buttons {
        flex-direction: column;
        align-items: center;
      }
    }

    @media (max-width: 480px) {
      .container {
        margin: 10px 5px;
        padding: 30px 20px;
      }

      h1 {
        font-size: 2rem;
      }



      .track {
        grid-template-columns: 60px 1fr 90px;
        gap: 10px;
        padding: 12px;
      }

      .track-icon {
        width: 28px;
        height: 28px;
        font-size: 16px;
      }

      /* Make track-meta even more compact on small mobile */
      .track-meta {
        gap: 1px;
        align-items: center;
      }

      /* Hide track info on small screens */
      .track-info {
        display: none;
      }
    }

    /* Custom scrollbar */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb {
      background: linear-gradient(135deg, #64ffda, #00d4ff);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(135deg, #00d4ff, #64ffda);
    }

    /* Selection styling */
    ::selection {
      background: rgba(100, 255, 218, 0.3);
      color: #ffffff;
    }

    ::-moz-selection {
      background: rgba(100, 255, 218, 0.3);
      color: #ffffff;
    }

    /* Marks display styling */
    .marks-container {
      margin-top: 20px;
      padding: 15px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .marks-list {
      color: rgba(255, 255, 255, 0.8);
      font-size: 0.9rem;
    }

    .mark-item {
      color: #64ffda;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 6px;
      transition: all 0.2s ease;
      display: inline-block;
      margin: 2px 0;
    }

    .mark-item:hover {
      background: rgba(100, 255, 218, 0.1);
      color: #ffffff;
      transform: translateY(-1px);
    }

    .mark-item:active {
      transform: translateY(0);
    }

    /* Keyboard shortcuts info */
        .keyboard-info {
      margin-top: 15px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      font-size: 0.8rem;
      color: rgba(255, 255, 255, 0.6);
    }

    .keyboard-info strong {
      color: rgba(255, 255, 255, 0.8);
    }

    .keyboard-info .key {
      background: rgba(255, 255, 255, 0.1);
      padding: 2px 6px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 0.75rem;
    }

    /* Bottom controls styling */
    .bottom-controls {
      margin-top: 30px;
      padding: 25px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(15px);
      -webkit-backdrop-filter: blur(15px);
    }

    /* Effects controls styling */
        .effects-controls {
      margin-top: 20px;
      padding: 20px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .effects-controls h4 {
      margin: 0 0 15px 0;
      color: rgba(255, 255, 255, 0.9);
      font-size: 1rem;
      text-align: center;
    }

    .effects-buttons {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
    }

        .effect-btn {
      background: rgba(100, 255, 218, 0.1);
      border: 1px solid rgba(100, 255, 218, 0.3);
      color: #64ffda;
      padding: 12px 16px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 500;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    .effect-btn:hover {
      background: rgba(100, 255, 218, 0.2);
      border-color: rgba(100, 255, 218, 0.5);
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(100, 255, 218, 0.2);
    }

    .effect-btn:active {
      transform: translateY(0);
    }

    .effect-btn.active {
      background: rgba(100, 255, 218, 0.3);
      border-color: #64ffda;
      color: #ffffff;
      box-shadow: 0 0 20px rgba(100, 255, 218, 0.4);
    }

    @media (max-width: 768px) {
      .effects-buttons {
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
      }

      .effect-btn {
        padding: 10px 12px;
        font-size: 0.8rem;
      }
    }

    @media (max-width: 480px) {
      .effects-buttons {
        grid-template-columns: 1fr;
        gap: 8px;
      }
    }

    /* Responsive bottom controls */
    @media (max-width: 768px) {
      .bottom-controls {
        margin-top: 20px;
        padding: 20px;
      }

      .master-volume {
        flex-direction: column;
        gap: 10px;
        text-align: center;
      }

      .volume-slider {
        width: 120px;
      }
    }

    @media (max-width: 480px) {
      .bottom-controls {
        margin-top: 15px;
        padding: 15px;
      }

      .keyboard-info {
        font-size: 0.75rem;
      }

      .key {
        padding: 1px 4px;
        font-size: 0.7rem;
      }
    }

        /* Krazy slider styling within effects controls */
    .krazy-slider-container {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 8px 0;
      justify-content: center;
      padding: 0;
      background: transparent;
      border: none;
      border-radius: 0;
    }

    .krazy-slider {
      flex: 1;
      max-width: 120px;
      height: 4px;
      border-radius: 2px;
      background: linear-gradient(90deg, rgba(255, 100, 100, 0.3), rgba(255, 150, 100, 0.6));
      outline: none;
      -webkit-appearance: none;
      appearance: none;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
    }

    /* Add sticky position indicators for krazy slider */
    .krazy-slider::before {
      content: '';
      position: absolute;
      top: -2px;
      left: 0;
      right: 0;
      height: 8px;
      background: repeating-linear-gradient(
        to right,
        transparent,
        transparent calc(25% - 1px),
        rgba(255, 100, 100, 0.4) calc(25% - 1px),
        rgba(255, 100, 100, 0.4) calc(25% + 1px),
        transparent calc(25% + 1px)
      );
      pointer-events: none;
      z-index: 1;
    }

    .krazy-slider:hover {
      background: linear-gradient(90deg, rgba(255, 100, 100, 0.5), rgba(255, 150, 100, 0.8));
      transform: scaleY(1.2);
    }

    .krazy-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 2px;
      background: linear-gradient(135deg, #ff6b6b, #ff8e8e, #ffb366);
      cursor: pointer;
      border: 1px solid rgba(255, 255, 255, 0.4);
      box-shadow: 0 0 12px rgba(255, 100, 100, 0.6), inset 0 1px 2px rgba(255, 255, 255, 0.3);
      transition: all 0.2s ease;
    }

    .krazy-slider::-webkit-slider-thumb:hover {
      transform: scale(1.1);
      box-shadow: 0 0 20px rgba(255, 100, 100, 0.8), inset 0 1px 2px rgba(255, 255, 255, 0.4);
    }

    .krazy-slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 2px;
      background: linear-gradient(135deg, #ff6b6b, #ff8e8e, #ffb366);
      cursor: pointer;
      border: 1px solid rgba(255, 255, 255, 0.4);
      box-shadow: 0 0 12px rgba(255, 100, 100, 0.6), inset 0 1px 2px rgba(255, 255, 255, 0.3);
      transition: all 0.2s ease;
    }

    .krazy-value {
      color: #ff6b6b;
      font-weight: 600;
      font-size: 0.8rem;
      min-width: 20px;
      text-align: center;
      text-shadow: 0 0 8px rgba(255, 100, 100, 0.5);
      font-family: 'Courier New', monospace;
    }

    @media (max-width: 768px) {
      .krazy-slider-container {
        flex-direction: row;
        gap: 6px;
        margin: 6px 0;
      }

      .krazy-slider {
        max-width: 100px;
      }

      .krazy-value {
        font-size: 0.75rem;
        min-width: 18px;
      }
    }

    /* Cache controls styling */
        .cache-controls {
      margin-top: 20px;
      padding: 20px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .cache-controls h4 {
      margin: 0 0 15px 0;
      color: rgba(255, 255, 255, 0.9);
      font-size: 1rem;
      text-align: center;
    }

    .cache-buttons {
      display: flex;
      gap: 12px;
      justify-content: center;
      margin-bottom: 15px;
    }

    .cache-btn {
      background: rgba(100, 255, 218, 0.1);
      border: 1px solid rgba(100, 255, 218, 0.3);
      color: #64ffda;
      padding: 10px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 500;
      transition: all 0.3s ease;
    }

    .cache-btn:hover {
      background: rgba(100, 255, 218, 0.2);
      border-color: rgba(100, 255, 218, 0.5);
      transform: translateY(-1px);
    }

    .cache-status {
      text-align: center;
      color: rgba(255, 255, 255, 0.7);
      font-size: 0.9rem;
    }

    .cache-indicator {
      margin-right: 8px;
    }

    @media (max-width: 768px) {
      .cache-buttons {
        flex-direction: column;
        gap: 8px;
      }

      .cache-btn {
        padding: 8px 12px;
        font-size: 0.8rem;
      }
    }

        /* Simple Player Interface */
    .webamp-container {
      margin-bottom: 40px;
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, sans-serif;
      display: flex;
      flex-direction: column;
      gap: 20px;
      max-width: 800px;
      margin-left: auto;
      margin-right: auto;
    }

    .window {
      background: transparent;
      color: #ffffff;
      border: none;
      border-radius: 0;
      overflow: visible;
      margin: 0 auto;
      box-shadow: none;
      position: relative;
    }

    /* Main Player Window */
    #webamp #main-window {
      width: 320px;
      padding: 8px;
      box-sizing: border-box;
      overflow: hidden;
    }

    .player-main {
      display: flex;
      flex-direction: column;
      gap: 8px;
      width: 100%;
      box-sizing: border-box;
      overflow: hidden;
    }

    .top-row {
      display: flex;
      justify-content: flex-start;
      align-items: flex-start;
      gap: 12px;
      height: 40px;
      width: 100%;
      box-sizing: border-box;
      overflow: hidden;
    }

    .right-panel {
      display: flex;
      flex-direction: column;
      gap: 8px;
      flex: 1;
      min-width: 0;
      overflow: hidden;
      box-sizing: border-box;
    }

    .controls-row {
      display: flex;
      gap: 8px;
      align-items: center;
      width: 100%;
      box-sizing: border-box;

    }

    .visualizer {
      background: #000;
      border: 1px solid #555;
      padding: 4px;
      position: relative;
      width: 120px;
      height: 40px;
      min-width: 120px;
      min-height: 40px;
      max-width: 120px;
      max-height: 40px;
      flex-shrink: 0;
      box-sizing: border-box;
    }

    .time-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: #ff6b6b;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      font-weight: bold;
      padding: 2px 6px;
      border-radius: 3px;
      z-index: 10;
      pointer-events: none;
    }

    /* Progress Bar */
    .progress-container {
      width: 100%;
      margin: 8px 0;
      box-sizing: border-box;
      overflow: hidden;
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: #333;
      border: 1px solid #555;
      border-radius: 2px;
      position: relative;
      cursor: pointer;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff6b6b, #ff4757);
      border-radius: 1px;
      width: 0%;
      transition: width 0.1s ease;
    }

    .progress-handle {
      width: 12px;
      height: 12px;
      background: #fff;
      border: 1px solid #555;
      border-radius: 2px;
      position: absolute;
      top: -2px;
      left: 0%;
      cursor: pointer;
      z-index: 5;
    }



    .control-btn {
      width: 40px;
      height: 40px;
      min-width: 40px;
      min-height: 40px;
      max-width: 40px;
      max-height: 40px;
      background: #333;
      border: 1px solid #555;
      border-radius: 2px;
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      transition: all 0.1s ease;
      margin: 0;
      padding: 0;
      flex-shrink: 0;
      box-sizing: border-box;
    }

    .control-btn:hover {
      background: #555;
      border-color: #777;
    }

    .control-buttons {
      display: flex;
      gap: 2px;
      justify-content: center;
      width: 100%;
      box-sizing: border-box;
      overflow: hidden;
    }

    .control-btn.play-btn {
      background: #4CAF50;
      border-color: #45a049;
      box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
    }

    .control-btn.play-btn:hover {
      background: #45a049;
      border-color: #64ffda;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
    }

    .control-btn.selected {
      background: #64ffda;
      border-color: #64ffda;
      color: #1a1a2e;
      box-shadow: 0 4px 12px rgba(100, 255, 218, 0.4);
    }

    .control-btn.disabled {
      opacity: 0.5;
      cursor: not-allowed;
      background: #1a1a2e;
      border-color: #333;
      position: relative;
    }

    .control-btn.disabled:hover {
      transform: none;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }



    .download-btn {
      background: #4CAF50;
      border-color: #45a049;
      color: #fff;
    }

    .download-btn:hover {
      background: #45a049;
      border-color: #64ffda;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
    }

    .download-btn.downloading {
      background: #ff9800;
      border-color: #f57c00;
      animation: pulse 1.5s infinite;
    }

    .download-btn.downloaded {
      background: #2196F3;
      border-color: #1976D2;
    }

    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.7; }
      100% { opacity: 1; }
    }

    /* Song Title */
    .song-title {
      font-size: 14px;
      font-weight: bold;
      color: #ff6b6b;
      white-space: nowrap;
      margin-bottom: 4px;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
      box-sizing: border-box;
    }





    .time-display {
      font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, monospace;
      font-size: 16px;
      color: #64ffda;
      font-weight: 500;
    }

    .slider {
      width: 60px;
      height: 8px;
      background: #2a2a3e;
      border-radius: 2px;
      outline: none;
      cursor: pointer;
      -webkit-appearance: none;
      border: 1px solid #444;
      flex-shrink: 0;
      box-sizing: border-box;
      position: relative;
    }

    /* Add sticky position indicators for sliders */
    .slider::before {
      content: '';
      position: absolute;
      top: -2px;
      left: 0;
      right: 0;
      height: 12px;
      background: repeating-linear-gradient(
        to right,
        transparent,
        transparent calc(25% - 1px),
        rgba(255, 107, 107, 0.3) calc(25% - 1px),
        rgba(255, 107, 107, 0.3) calc(25% + 1px),
        transparent calc(25% + 1px)
      );
      pointer-events: none;
      z-index: 1;
    }

    .volume-slider {
      background: #ff6b6b;
    }

    .balance-slider {
      background: #4ecdc4;
    }

    /* Special styling for balance slider to show center position */
    .balance-slider::before {
      background: repeating-linear-gradient(
        to right,
        transparent,
        transparent calc(50% - 1px),
        rgba(78, 205, 196, 0.5) calc(50% - 1px),
        rgba(78, 205, 196, 0.5) calc(50% + 1px),
        transparent calc(50% + 1px)
      );
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      background: #64ffda;
      border-radius: 2px;
      cursor: pointer;
      box-shadow: 0 0 12px rgba(100, 255, 218, 0.6);
      border: 2px solid #fff;
    }

    .slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: #64ffda;
      border-radius: 2px;
      cursor: pointer;
      border: 2px solid #fff;
      box-shadow: 0 0 12px rgba(100, 255, 218, 0.6);
    }



    /* Playlist Window */
    #webamp #playlist-window {
      width: 280px;
      padding: 8px;
    }

    .playlist-content {
      background: transparent;
      padding: 0;
      min-height: auto;
    }

    .track-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 8px;
      color: #ff6b6b;
      font-size: 11px;
      font-family: 'Courier New', monospace;
      cursor: pointer;
      border: none;
      background: transparent;
    }

    .track-item:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .track-item.current {
      background: #4ecdc4;
      color: #fff;
    }

    .track-number {
      width: 20px;
      color: #ff6b6b;
    }

    .track-name {
      flex: 1;
      color: inherit;
    }







    .track-name {
      flex: 1;
      font-weight: 600;
      color: #fff;
      font-size: 15px;
    }









    /* Responsive adjustments */
    @media (max-width: 768px) {
      .webamp-container {
        gap: 16px;
      }

      .window {
        margin: 0 auto;
      }

      #main-window {
        width: 280px;
        padding: 6px;
      }

      #playlist-window {
        width: 240px;
        padding: 6px;
      }

      .visualizer {
        width: 100px;
        height: 35px;
        min-width: 100px;
        min-height: 35px;
        max-width: 100px;
        max-height: 35px;
      }

      .slider {
        width: 50px;
      }

      /* Adjust sticky indicators for mobile */
      .slider::before {
        height: 10px;
        top: -1px;
      }

      .track-volume::before {
        height: 8px;
        top: -1px;
      }

      .krazy-slider::before {
        height: 6px;
        top: -1px;
      }

      .control-btn {
        width: 32px;
        height: 32px;
        min-width: 32px;
        min-height: 32px;
        max-width: 32px;
        max-height: 32px;
        font-size: 12px;
        box-sizing: border-box;
      }

      .download-btn {
        font-size: 10px;
      }

      .track-btn {
        width: 20px;
        height: 20px;
        font-size: 9px;
      }

      .progress-bar {
        height: 6px;
      }

      .progress-handle {
        width: 10px;
        height: 10px;
      }
    }

    @media (max-width: 480px) {
      .webamp-container {
        gap: 12px;
      }

      #main-window {
        width: 260px;
        padding: 4px;
      }

      #playlist-window {
        width: 220px;
        padding: 4px;
      }

      .visualizer {
        width: 90px;
        height: 30px;
        min-width: 90px;
        min-height: 30px;
        max-width: 90px;
        max-height: 30px;
      }

      .slider {
        width: 45px;
      }

      /* Adjust sticky indicators for small mobile */
      .slider::before {
        height: 8px;
        top: -1px;
      }

      .track-volume::before {
        height: 6px;
        top: -1px;
      }

      .krazy-slider::before {
        height: 5px;
        top: -1px;
      }

      .control-btn {
        width: 28px;
        height: 28px;
        min-width: 28px;
        min-height: 28px;
        max-width: 28px;
        max-height: 28px;
        font-size: 10px;
        box-sizing: border-box;
      }

      .download-btn {
        font-size: 8px;
      }

      .track-btn {
        width: 18px;
        height: 18px;
        font-size: 8px;
      }

      .progress-bar {
        height: 5px;
      }

      .progress-handle {
        width: 8px;
        height: 8px;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <header>
      <h1>Suno Multitrack Player</h1>
      <p class="subtitle">Multi-track audio player for Suno-generated music with individual track controls</p>
    </header>

        <div id="webamp" class="webamp-container">
            <!-- Compact Player Window -->
      <div id="main-window" class="window">
        <div class="player-main">
                    <div class="top-row">
            <div class="visualizer">
              <canvas id="masterWaveform" width="120" height="40"></canvas>
              <div class="time-overlay">
                <span id="currentTime">0:00</span>
              </div>
            </div>
            <div class="right-panel">
              <div id="currentSongTitle" class="song-title">🏠 На старой даче</div>
              <div class="controls-row">
                <input id="masterVolume" type="range" min="0" max="100" value="80" class="slider volume-slider">
                <input id="balance" type="range" min="-100" max="100" value="0" class="slider balance-slider">
              </div>
            </div>
          </div>

          <div class="progress-container" id="mainProgress">
            <div class="progress-bar">
              <div class="progress-fill" id="main-progress-fill"></div>
              <div class="progress-handle" id="main-progress-handle"></div>
            </div>
          </div>

          <div class="control-buttons">
            <button class="control-btn download-btn" id="downloadAll" title="Download all tracks">⬇</button>
            <button class="control-btn" id="previous">⏮</button>
            <button class="control-btn play-btn" id="play">▶</button>
            <button class="control-btn" id="pause">⏸</button>
            <button class="control-btn" id="stop">⏹</button>
            <button class="control-btn" id="next">⏭</button>
          </div>

        </div>
      </div>

            <!-- Compact Playlist Window -->
      <div id="playlist-window" class="window">
        <div class="playlist-content">
          <div class="track-item" data-song="dacha">
            <span class="track-number">1.</span>
            <span class="track-name">🏠 На старой даче</span>
          </div>
          <div class="track-item" data-song="ulitsa">
            <span class="track-number">2.</span>
            <span class="track-name">🌃 Улица знает всё</span>
          </div>
          <div class="track-item" data-song="pukersy">
            <span class="track-number">3.</span>
            <span class="track-name">🎰 Пукерсы</span>
          </div>
          <div class="track-item" data-song="jongler">
            <span class="track-number">4.</span>
            <span class="track-name">🤹 Жонглёр Серёга</span>
          </div>
          <div class="track-item" data-song="kaskadny">
            <span class="track-number">5.</span>
            <span class="track-name">🌊 Каскадный бит</span>
          </div>
        </div>
      </div>




    <div class="tracks-container">
      <div id="tracksList">
        <div class="loading">Loading tracks...</div>
      </div>
    </div>

    <div class="bottom-controls">

      <div class="effects-controls">
        <h4>Fun Effects</h4>
        <div class="krazy-slider-container">
          <input type="range" class="krazy-slider" id="krazySlider" min="0" max="100" value="50">
          <span class="krazy-value" id="krazyValue">50</span>
        </div>
        <div class="effects-buttons">
                                  <button class="effect-btn" id="noiseBtn" data-effect="noise">🎭 Noise Flanger</button>
          </div>
        </div>

      <div class="keyboard-info">
        <strong>Keyboard Shortcuts:</strong><br>
        <span class="key">Space</span> Play/Pause •
        <span class="key">←</span> <span class="key">→</span> Skip 5s •
        <span class="key">K</span> Add Mark •
        <span class="key">Shift</span>+<span class="key">←</span> <span class="key">Shift</span>+<span class="key">→</span> Jump Between Marks
      </div>

      <div class="cache-controls">
        <h4>Audio Cache</h4>
        <div class="cache-buttons">
          <button class="cache-btn" id="clearCacheBtn">🗑️ Clear Cache</button>
          <button class="cache-btn" id="cacheInfoBtn">ℹ️ Cache Info</button>
        </div>
        <div class="cache-status" id="cacheStatus">
          <span class="cache-indicator">🟢</span> Cache enabled
        </div>
      </div>
    </div>
  </div>

  <script>
    // Console logging class that only outputs on localhost
    class ConsoleLogger {
      constructor() {
        this.isLocalhost = window.location.hostname === 'localhost' ||
                           window.location.hostname === '127.0.0.1' ||
                           window.location.hostname.includes('localhost');
      }

      isEnabled() {
        return this.isLocalhost;
      }

      log(...args) {
        if (this.isLocalhost) {
          console.log(...args);
        }
      }

      error(...args) {
        if (this.isLocalhost) {
          console.error(...args);
        }
      }

      warn(...args) {
        if (this.isLocalhost) {
          console.warn(...args);
        }
      }
    }

    const logger = new ConsoleLogger();

    class MultitrackPlayer {
      constructor() {
        this.audioContext = null;
        this.tracks = [];
        this.currentSong = 'dacha';
        this.isPlaying = false;
        this.currentTime = 0;
        this.duration = 0;
        this.masterGain = null;
        this.soloedTracks = new Set();
        this.marks = []; // Array to store time marks

        // Effects properties
        this.effects = {
          noise: { active: false, node: null }
        };

        // Audio caching properties
        this.audioCache = new Map(); // In-memory cache
        this.cacheExpiry = 30 * 60 * 1000; // 30 minutes cache expiry

        this.initializeAudio();
        this.setupEventListeners();
        this.initializeComponents();

        // Load initial tracks and check cache on startup
        setTimeout(async () => {
          await this.loadTracks();
          await this.updatePlaylistCacheIndicators();
          this.updatePlayButtonState();
        }, 200);
      }

      async initializeAudio() {
        try {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          this.masterGain = this.audioContext.createGain();
          this.stereoPanner = this.audioContext.createStereoPanner();
          this.stereoPanner.pan.value = 0;

                    // iOS-specific audio context setup - silent unlock
          if (this.audioContext.state === 'suspended') {
            logger.log('iOS Audio Context: Context created in suspended state, will unlock on user interaction');
          }

          // Connect: masterGain -> stereoPanner -> destination
          this.masterGain.connect(this.stereoPanner);
          this.stereoPanner.connect(this.audioContext.destination);
          this.masterGain.gain.value = 0.8;

          // Mark that master gain is connected to destination
          this.masterGain.connectedToDestination = true;



          logger.log('Audio context created, state:', this.audioContext.state);

          // iOS Safari audio context handling
          if (this.audioContext.state === 'suspended') {
            logger.log('Audio context suspended, waiting for user interaction...');

            // Create a one-time click handler to resume audio context
            const resumeAudioContext = async () => {
              try {
                await this.audioContext.resume();
                logger.log('Audio context resumed successfully, state:', this.audioContext.state);

                // Remove the event listeners after successful resume
                document.removeEventListener('touchstart', resumeAudioContext);
                document.removeEventListener('mousedown', resumeAudioContext);
                document.removeEventListener('keydown', resumeAudioContext);

                // Update UI to show audio is ready
                this.updateAudioReadyState();
              } catch (error) {
                logger.error('Failed to resume audio context:', error);
              }
            };

            // Add event listeners for iOS audio context resume
            document.addEventListener('touchstart', resumeAudioContext, { once: true });
            document.addEventListener('mousedown', resumeAudioContext, { once: true });
            document.addEventListener('keydown', resumeAudioContext, { once: true });
          }

        } catch (error) {
          logger.error('Failed to initialize audio context:', error);
        }

        // Initialize master waveform
        this.initializeMasterWaveform();

        // Handle responsive canvas sizing
        this.handleResponsiveCanvas();
        window.addEventListener('resize', () => this.handleResponsiveCanvas());
      }

      updateAudioReadyState() {
        logger.log('Audio ready state updated - audio context is now running');

        // Update play button state
        const playBtn = document.getElementById('play');
        if (playBtn) {
          playBtn.disabled = false;
          playBtn.title = 'Play audio';
        }

        // Show success message
        const readyMsg = document.createElement('div');
        readyMsg.style.cssText = 'position:fixed;top:20px;right:20px;background:#4CAF50;color:white;padding:10px;border-radius:5px;z-index:9999;';
        readyMsg.textContent = '🎵 Audio ready!';
        document.body.appendChild(readyMsg);
        setTimeout(() => readyMsg.remove(), 3000);
      }

      initializeMasterWaveform() {
        const canvas = document.getElementById('masterWaveform');
        if (!canvas) return;

        this.masterWaveformCtx = canvas.getContext('2d');
        this.masterWaveformCanvas = canvas;

        // Set canvas size
        canvas.width = 120;
        canvas.height = 40;

        // Initialize oscilloscope
        this.oscilloscopeData = new Float32Array(400);
        this.oscilloscopeIndex = 0;

        // Create analyser node for real-time audio data
        this.oscilloscopeAnalyser = this.audioContext.createAnalyser();
        this.oscilloscopeAnalyser.fftSize = 512;
        this.oscilloscopeAnalyser.smoothingTimeConstant = 0.3;

        // Connect stereo panner to analyser for balance visualization
        this.stereoPanner.connect(this.oscilloscopeAnalyser);

        // Start oscilloscope animation
        this.startOscilloscope();
      }

      startOscilloscope() {
        const updateOscilloscope = () => {
          if (this.isPlaying && this.oscilloscopeAnalyser) {
            this.updateOscilloscope();
          }
          requestAnimationFrame(updateOscilloscope);
        };
        updateOscilloscope();
      }

      handleResponsiveCanvas() {
        const canvas = document.getElementById('masterWaveform');
        if (!canvas) return;

        let width = 120;
        let height = 40;

        if (window.innerWidth <= 480) {
          width = 90;
          height = 30;
        } else if (window.innerWidth <= 768) {
          width = 100;
          height = 35;
        }

        canvas.width = width;
        canvas.height = height;

        // Update visualizer container dimensions
        const visualizer = document.querySelector('.visualizer');
        if (visualizer) {
          visualizer.style.width = width + 'px';
          visualizer.style.height = height + 'px';
          visualizer.style.minWidth = width + 'px';
          visualizer.style.minHeight = height + 'px';
          visualizer.style.maxWidth = width + 'px';
          visualizer.style.maxHeight = height + 'px';
        }
      }

      updateOscilloscope() {
        if (!this.masterWaveformCtx || !this.masterWaveformCanvas || !this.oscilloscopeAnalyser) return;

        const ctx = this.masterWaveformCtx;
        const canvas = this.masterWaveformCanvas;

        // Get real-time audio data
        const dataArray = new Float32Array(this.oscilloscopeAnalyser.frequencyBinCount);
        this.oscilloscopeAnalyser.getFloatTimeDomainData(dataArray);

        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw background
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw grid lines
        ctx.strokeStyle = 'rgba(255, 107, 107, 0.2)';
        ctx.lineWidth = 1;

        // Vertical grid lines - scale based on canvas width
        const gridSpacingX = Math.max(20, Math.floor(canvas.width / 3));
        for (let x = 0; x < canvas.width; x += gridSpacingX) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
          ctx.stroke();
        }

        // Horizontal grid lines - scale based on canvas height
        const gridSpacingY = Math.max(10, Math.floor(canvas.height / 2));
        for (let y = 0; y < canvas.height; y += gridSpacingY) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
          ctx.stroke();
        }

        // Draw oscilloscope trace
        ctx.strokeStyle = '#ff6b6b';
        ctx.lineWidth = 2;
        ctx.beginPath();

        const centerY = canvas.height / 2;
        const scale = canvas.height / 2;

        for (let i = 0; i < canvas.width; i++) {
          const dataIndex = Math.floor((i / canvas.width) * dataArray.length);
          if (dataIndex < dataArray.length) {
            const x = i;
            const y = centerY + (dataArray[dataIndex] * scale);

            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
        }

        ctx.stroke();

        // Draw center line
        ctx.strokeStyle = 'rgba(255, 107, 107, 0.3)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, centerY);
        ctx.lineTo(canvas.width, centerY);
        ctx.stroke();
      }

      updateMasterWaveformPosition(percentage) {
        // No position indicator needed - just update the oscilloscope
        if (this.oscilloscopeAnalyser) {
          this.updateOscilloscope();
        }
      }

      setupEventListeners() {
        // Mobile unlock (Safari/Firefox Focus): resume audio on first user gesture and visibility change
        const unlock = async () => {
          try {
            if (this.audioContext && this.audioContext.state !== 'running') {
              await this.audioContext.resume();
            }
          } catch (_) {}
        };
        ['touchstart','touchend','mousedown','keydown','pointerdown'].forEach(evt => {
          window.addEventListener(evt, unlock, { once: true, passive: true });
        });
        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'visible') unlock();
        });

        // Simple playlist event listeners
        document.querySelectorAll('.track-item').forEach(item => {
          item.addEventListener('click', () => {
            const song = item.dataset.song;
            if (song) {
              this.changeSong(song);

              // Update active state
              document.querySelectorAll('.track-item').forEach(i => i.classList.remove('current'));
              item.classList.add('current');
            }
          });
        });

        // Control buttons
        document.getElementById('previous').addEventListener('click', () => {
          const currentSong = this.currentSong;
          const songs = ['dacha', 'ulitsa', 'pukersy', 'jongler', 'kaskadny'];
          const currentIndex = songs.indexOf(currentSong);
          const prevIndex = (currentIndex - 1 + songs.length) % songs.length;
          this.changeSong(songs[prevIndex]);
        });

        document.getElementById('next').addEventListener('click', () => {
          const currentSong = this.currentSong;
          const songs = ['dacha', 'ulitsa', 'pukersy', 'jongler', 'kaskadny'];
          const currentIndex = songs.indexOf(currentSong);
          const nextIndex = (currentIndex + 1) % songs.length;
          this.changeSong(songs[nextIndex]);
        });

                // Action buttons
        document.getElementById('play').addEventListener('click', () => {
          const playBtn = document.getElementById('play');
          if (playBtn.disabled) return;
          this.play();
        });

        document.getElementById('pause').addEventListener('click', () => {
          logger.log('Pause button clicked');
          this.pause();
        });

        document.getElementById('stop').addEventListener('click', () => {
          logger.log('Stop button clicked');
          this.stop();
        });

        // Progress bar seeking - use more specific selector
        const mainProgressBar = document.querySelector('#mainProgress .progress-bar');
        if (mainProgressBar) {
          mainProgressBar.addEventListener('click', (e) => {
            const rect = e.currentTarget.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const percentage = clickX / rect.width;
            const seekTime = percentage * this.duration;

            logger.log(`Progress bar click: ${clickX}px, ${percentage * 100}%, seeking to ${seekTime}s`);
            this.seekToTime(seekTime);
          });
        } else {
          logger.warn('Main progress bar not found for seeking');
        }

        // Master waveform seeking
        const masterWaveform = document.getElementById('masterWaveform');
        if (masterWaveform) {
          masterWaveform.addEventListener('click', (e) => {
            const rect = e.currentTarget.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const percentage = clickX / rect.width;
            const seekTime = percentage * this.duration;

            logger.log(`Master waveform click: ${clickX}px, ${percentage * 100}%, seeking to ${seekTime}s`);
            this.seekToTime(seekTime);
          });
        } else {
          logger.warn('Master waveform not found for seeking');
        }

        // Volume slider with sticky positions
        const volumeSlider = document.getElementById('masterVolume');
        volumeSlider.addEventListener('input', (e) => {
          if (this.masterGain) {
            this.masterGain.gain.value = e.target.value / 100;
          }
        });

        // Add sticky positions for volume slider
        volumeSlider.addEventListener('change', (e) => {
          const value = parseInt(e.target.value);
          const stickyPositions = [0, 25, 50, 75, 100];
          const closest = stickyPositions.reduce((prev, curr) => {
            return (Math.abs(curr - value) < Math.abs(prev - value) ? curr : prev);
          });

          if (Math.abs(closest - value) <= 5) { // 5% tolerance
            e.target.value = closest;
            if (this.masterGain) {
              this.masterGain.gain.value = closest / 100;
            }
          }
        });

        // Balance slider with sticky positions
        const balanceSlider = document.getElementById('balance');
        balanceSlider.addEventListener('input', (e) => {
          const balanceValue = parseFloat(e.target.value);
          if (this.stereoPanner) {
            this.stereoPanner.pan.value = balanceValue / 100;
          }
          logger.log('Balance changed to:', balanceValue);
        });

        // Add sticky positions for balance slider
        balanceSlider.addEventListener('change', (e) => {
          const value = parseInt(e.target.value);
          const stickyPositions = [-100, -50, 0, 50, 100];
          const closest = stickyPositions.reduce((prev, curr) => {
            return (Math.abs(curr - value) < Math.abs(prev - value) ? curr : prev);
          });

          if (Math.abs(closest - value) <= 10) { // 10% tolerance for balance
            e.target.value = closest;
            if (this.stereoPanner) {
              this.stereoPanner.pan.value = closest / 100;
            }
          }
        });

        // Effects
                  document.getElementById('noiseBtn').addEventListener('click', () => this.toggleEffect('noise'));

        // Krazy parameter
        document.getElementById('krazySlider').addEventListener('input', (e) => {
          this.setKrazyLevel(e.target.value);
        });

        // Add sticky positions for krazy slider
        document.getElementById('krazySlider').addEventListener('change', (e) => {
          const value = parseInt(e.target.value);
          const stickyPositions = [0, 25, 50, 75, 100];
          const closest = stickyPositions.reduce((prev, curr) => {
            return (Math.abs(curr - value) < Math.abs(prev - value) ? curr : prev);
          });

          if (Math.abs(closest - value) <= 5) { // 5% tolerance
            e.target.value = closest;
            this.setKrazyLevel(closest);
            // Update the display value
            const krazyValue = document.getElementById('krazyValue');
            if (krazyValue) {
              krazyValue.textContent = closest;
            }
          }
        });

        // Update krazy value display on input
        document.getElementById('krazySlider').addEventListener('input', (e) => {
          const krazyValue = document.getElementById('krazyValue');
          if (krazyValue) {
            krazyValue.textContent = e.target.value;
          }
        });

        // Download all tracks button
        const downloadAllBtn = document.getElementById('downloadAll');
        if (downloadAllBtn) {
          logger.log('Setting up download all button event listener');
          downloadAllBtn.addEventListener('click', () => {
            logger.log('Download all button clicked');
            this.downloadAllTracks();
          });
        } else {
          logger.log('Download all button not found');
        }

        // Cache controls are now handled in initializeCacheControls()
        // No duplicate event listeners here

        // Keyboard shortcuts - removed for now
      }

      // Initialize additional components
      initializeComponents() {
        // Initialize keyboard shortcuts
        this.initializeKeyboardShortcuts();

        // Initialize effects controls
        this.initializeEffectsControls();

        // Initialize cache controls
        this.initializeCacheControls();

        // Register service worker for enhanced caching
        this.registerServiceWorker();

        // Check for cached tracks and render them immediately
        this.checkAndRenderCachedTracks();
      }

            async checkAndRenderCachedTracks() {
        // This method is called after tracks are initialized
        // Check if any tracks are already cached and render them
        const songData = this.getSongData();
        const cachePromises = [];
        let skippedCount = 0;

        logger.log('=== CACHE CHECK STARTING ===');

        for (let i = 0; i < songData.length; i++) {
          const track = this.tracks[i];
          if (track) {
            // Always check cache for all tracks, regardless of isDownloaded state
            // This ensures that after cache clearing, we properly re-check all tracks
            logger.log(`Checking cache for track ${track.id} (force check)`);
            const cachePromise = this.checkAndRenderCachedTrack(songData[i], i);
            cachePromises.push(cachePromise);
          } else {
            logger.log(`No track found at index ${i}`);
          }
        }

        // Wait for all cache checks to complete
        if (cachePromises.length > 0) {
          await Promise.all(cachePromises);
          logger.log(`Cache checking completed. Processed: ${cachePromises.length}, Skipped: ${skippedCount}`);
        } else {
          logger.log(`No tracks need cache checking. All tracks are already downloaded.`);
        }

        // FINAL PLACEHOLDER STATE MANAGEMENT
        logger.log('=== FINAL PLACEHOLDER STATE MANAGEMENT ===');
        this.tracks.forEach(track => {
          if (track.element) {
            const placeholder = track.element.querySelector('.placeholder-waveform');
            const canvas = track.element.querySelector('.waveform-canvas');
            const downloadOverlay = track.element.querySelector('.download-overlay');

            if (track.isDownloaded) {
              // DOWNLOADED TRACKS: Hide placeholder, show waveform, hide download
              if (placeholder) {
                placeholder.style.display = 'none';
                logger.log(`✓ Track ${track.id}: Hidden placeholder (downloaded)`);
              }
              if (canvas) {
                canvas.style.display = 'block';
                logger.log(`✓ Track ${track.id}: Showed waveform (downloaded)`);
              }
              if (downloadOverlay) {
                downloadOverlay.style.display = 'none';
                logger.log(`✓ Track ${track.id}: Hidden download overlay (downloaded)`);
              }
            } else {
              // NON-DOWNLOADED TRACKS: Hide placeholder, show download
              if (placeholder) {
                placeholder.style.display = 'none';
                logger.log(`✓ Track ${track.id}: Hidden placeholder (not downloaded)`);
              }
              if (canvas) {
                canvas.style.display = 'none';
                logger.log(`✓ Track ${track.id}: Hidden waveform (not downloaded)`);
              }
              if (downloadOverlay) {
                downloadOverlay.style.display = 'flex';
                logger.log(`✓ Track ${track.id}: Showed download overlay (not downloaded)`);
              }
            }
          }
        });

        logger.log('=== CACHE CHECK COMPLETED ===');

        // CRITICAL: Update duration after all cache loading is complete
        this.updateDuration();
        logger.log('Duration updated after cache loading');

        // FINAL CLEANUP: Force hide all placeholders and download overlays for downloaded tracks
        logger.log('=== FINAL CLEANUP: Force hiding placeholders and download overlays ===');
        this.tracks.forEach(track => {
          if (track.isDownloaded && track.element) {
            const placeholder = track.element.querySelector('.placeholder-waveform');
            const downloadOverlay = track.element.querySelector('.download-overlay');
            const canvas = track.element.querySelector('.waveform-canvas');

            if (placeholder) {
              placeholder.style.display = 'none';
              logger.log(`✓ Force hidden placeholder for ${track.id}`);
            }
            if (downloadOverlay) {
              downloadOverlay.style.display = 'none';
              logger.log(`✓ Force hidden download overlay for ${track.id}`);
            }
            if (canvas) {
              canvas.style.display = 'block';
              logger.log(`✓ Force showed waveform for ${track.id}`);
            }
          }
        });
        logger.log('=== FINAL CLEANUP COMPLETED ===');
      }

            async checkAndRenderCachedTrack(trackData, index) {
        const trackId = `track-${index}`;
        const track = this.tracks[index];

        if (!track) {
          logger.log(`No track found at index ${index}`);
          return;
        }

        // Note: We now check cache for all tracks, even if they think they're downloaded
        // This ensures proper behavior after cache clearing
        if (track.isDownloaded) {
          logger.log(`Track ${trackId} thinks it's downloaded, but checking cache anyway`);
        }

        try {
          // Check if track is cached
          const cachedAudio = await this.getCachedAudio(trackData.file);

          if (cachedAudio) {
            logger.log(`Track ${trackId} found in cache, rendering immediately`);

            // Decode the cached audio
            const audioBuffer = await this.decodeAudioData(cachedAudio);

            // Update track with cached data
            track.audioBuffer = audioBuffer;
            track.isDownloaded = true;

            // Create gain node
            track.gainNode = this.audioContext.createGain();
            track.gainNode.gain.value = track.volume;
            track.gainNode.connectedToMaster = true;
            track.gainNode.connect(this.masterGain);

            // Generate waveform
            this.generateWaveform(track, trackData.color);

            // Hide loading overlay and show waveform
            this.hideTrackLoadingOverlay(trackId);

            // IMMEDIATE UI UPDATE: Hide placeholder, show waveform, hide download
            const trackElement = track.element;
            if (trackElement) {
              const placeholder = trackElement.querySelector('.placeholder-waveform');
              if (placeholder) {
                placeholder.style.display = 'none';
                logger.log(`✓ ${trackId}: Hidden placeholder (cache hit)`);
              }

              const canvas = trackElement.querySelector('.waveform-canvas');
              if (canvas) {
                canvas.style.display = 'block';
                logger.log(`✓ ${trackId}: Showed waveform (cache hit)`);
              }

              const downloadOverlay = trackElement.querySelector('.download-overlay');
              if (downloadOverlay) {
                downloadOverlay.style.display = 'none';
                logger.log(`✓ ${trackId}: Hidden download overlay (cache hit)`);
              }
            }

            // Enable track controls
            this.enableTrackControls(trackId);

            // Update download status
            if (trackElement) {
              const downloadStatus = trackElement.querySelector('.download-status');
              if (downloadStatus) {
                const duration = audioBuffer.duration;
                const minutes = Math.floor(duration / 60);
                const seconds = Math.floor(duration % 60);
                downloadStatus.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                downloadStatus.style.color = '#64ffda';
              }
            }

            logger.log(`✓ Track ${trackId} restored from cache successfully`);

            // CRITICAL: Update duration after loading from cache
            this.updateDuration();
          } else {
            // Track not cached - reset track state and show download
            logger.log(`Track ${trackId} not cached, resetting state and showing download button`);

            // Reset track state since it's not actually cached
            track.isDownloaded = false;
            track.audioBuffer = null;

            const trackElement = track.element;
            if (trackElement) {
              const placeholder = trackElement.querySelector('.placeholder-waveform');
              if (placeholder) {
                placeholder.style.display = 'none';
                logger.log(`✓ ${trackId}: Hidden placeholder (cache miss)`);
              }

              const downloadOverlay = trackElement.querySelector('.download-overlay');
              if (downloadOverlay) {
                downloadOverlay.style.display = 'flex';
                logger.log(`✓ ${trackId}: Showed download overlay (cache miss)`);
              }

              // Hide waveform if it was showing
              const canvas = trackElement.querySelector('.waveform-canvas');
              if (canvas) {
                canvas.style.display = 'none';
                logger.log(`✓ ${trackId}: Hidden waveform (cache miss)`);
              }
            }
          }
        } catch (error) {
          logger.error(`Failed to restore cached track ${trackId}:`, error);

          // On error, hide placeholder and show download
          const trackElement = track.element;
          if (trackElement) {
            const placeholder = trackElement.querySelector('.placeholder-waveform');
            if (placeholder) {
              placeholder.style.display = 'none';
              logger.log(`✓ ${trackId}: Hidden placeholder (error)`);
            }

            const downloadOverlay = trackElement.querySelector('.download-overlay');
            if (downloadOverlay) {
              downloadOverlay.style.display = 'flex';
              logger.log(`✓ ${trackId}: Showed download overlay (error)`);
            }
          }
        }
      }

      async decodeAudioData(arrayBuffer) {
        // Safari-safe decode path: try promise decode first, fall back to callback API
        const decodeWithFallback = (ctx, buf) => new Promise((resolve, reject) => {
          try {
            const maybePromise = ctx.decodeAudioData(buf, resolve, reject);
            // If decodeAudioData returns a promise (modern spec), chain it
            if (maybePromise && typeof maybePromise.then === 'function') {
              maybePromise.then(resolve).catch(reject);
            }
          } catch (e) {
            reject(e);
          }
        });

        return await decodeWithFallback(this.audioContext, arrayBuffer);
      }

      async hasCachedTracksForSong(song) {
        const songData = this.getSongDataForSong(song);
        if (!songData) return false;

        for (const track of songData) {
          const cachedAudio = await this.getCachedAudio(track.file);
          if (cachedAudio) {
            return true; // At least one track is cached
          }
        }
        return false;
      }

      getSongDataForSong(song) {
        const songs = {
          ulitsa: [
            { name: 'Drums', icon: '🥁', color: '#4caf50', file: '/pages/20250821113700_suno_multitrack_example/Улица знает всё Stems/Улица знает всё (Drums).wav' },
            { name: 'Bass', icon: '🎸', color: '#ff9800', file: '/pages/20250821113700_suno_multitrack_example/Улица знает всё Stems/Улица знает всё (Bass).wav' },
            { name: 'Synth', icon: '🎹', color: '#2196f3', file: '/pages/20250821113700_suno_multitrack_example/Улица знает всё Stems/Улица знает всё (Synth).wav' }
          ],
          dacha: [
            { name: 'Vocals', icon: '🎤', color: '#ff69b4', file: '/pages/20250821113700_suno_multitrack_example/На старой даче Stems/На старой даче (Vocals).wav' },
            { name: 'Drums', icon: '🥁', color: '#4caf50', file: '/pages/20250821113700_suno_multitrack_example/На старой даче Stems/На старой даче (Drums).wav' },
            { name: 'Bass', icon: '🎸', color: '#ff9800', file: '/pages/20250821113700_suno_multitrack_example/На старой даче Stems/На старой даче (Bass).wav' },
            { name: 'Synth', icon: '🎹', color: '#2196f3', file: '/pages/20250821113700_suno_multitrack_example/На старой даче Stems/На старой даче (Synth).wav' }
          ],
          pukersy: [
            { name: 'Vocals', icon: '🎤', color: '#ff69b4', file: '/pages/20250821113700_suno_multitrack_example/Пукерсы Stems/Пукерсы (Vocals).wav' },
            { name: 'Synth', icon: '🎹', color: '#2196f3', file: '/pages/20250821113700_suno_multitrack_example/Пукерсы Stems/Пукерсы (Synth).wav' },
            { name: 'Percussion', icon: '🥁', color: '#ff9800', file: '/pages/20250821113700_suno_multitrack_example/Пукерсы Stems/Пукерсы (Percussion).wav' },
            { name: 'FX', icon: '🎛️', color: '#9c27b0', file: '/pages/20250821113700_suno_multitrack_example/Пукерсы Stems/Пукерсы (FX).wav' },
            { name: 'Drums', icon: '🥁', color: '#4caf50', file: '/pages/20250821113700_suno_multitrack_example/Пукерсы Stems/Пукерсы (Drums).wav' },
            { name: 'Bass', icon: '🎸', color: '#ff9800', file: '/pages/20250821113700_suno_multitrack_example/Пукерсы Stems/Пукерсы (Bass).wav' }
          ],
          jongler: [
            { name: 'Vocals', icon: '🎤', color: '#ff69b4', file: '/pages/20250821113700_suno_multitrack_example/Жонглёр Серёга Stems/Жонглёр Серёга (Vocals).wav' },
            { name: 'Synth', icon: '🎹', color: '#2196f3', file: '/pages/20250821113700_suno_multitrack_example/Жонглёр Серёга Stems/Жонглёр Серёга (Synth).wav' },
            { name: 'FX', icon: '🎛️', color: '#9c27b0', file: '/pages/20250821113700_suno_multitrack_example/Жонглёр Серёга Stems/Жонглёр Серёга (FX).wav' },
            { name: 'Drums', icon: '🥁', color: '#4caf50', file: '/pages/20250821113700_suno_multitrack_example/Жонглёр Серёга Stems/Жонглёр Серёга (Drums).wav' },
            { name: 'Bass', icon: '🎸', color: '#ff9800', file: '/pages/20250821113700_suno_multitrack_example/Жонглёр Серёга Stems/Жонглёр Серёга (Bass).wav' },
            { name: 'Backing Vocals', icon: '🎤', color: '#e91e63', file: '/pages/20250821113700_suno_multitrack_example/Жонглёр Серёга Stems/Жонглёр Серёга (Backing Vocals).wav' }
          ],
          kaskadny: [
            { name: 'Vocals', icon: '🎤', color: '#ff69b4', file: '/pages/20250821113700_suno_multitrack_example/Каскадный бит Stems/Каскадный бит (Vocals).wav' },
            { name: 'Synth', icon: '🎹', color: '#2196f3', file: '/pages/20250821113700_suno_multitrack_example/Каскадный бит Stems/Каскадный бит (Synth).wav' },
            { name: 'Percussion', icon: '🥁', color: '#ff9800', file: '/pages/20250821113700_suno_multitrack_example/Каскадный бит Stems/Каскадный бит (Percussion).wav' },
            { name: 'Keyboard', icon: '🎹', color: '#00bcd4', file: '/pages/20250821113700_suno_multitrack_example/Каскадный бит Stems/Каскадный бит (Keyboard).wav' },
            { name: 'Bass', icon: '🎸', color: '#ff9800', file: '/pages/20250821113700_suno_multitrack_example/Каскадный бит Stems/Каскадный бит (Bass).wav' },
            { name: 'Backing Vocals', icon: '🎤', color: '#e91e63', file: '/pages/20250821113700_suno_multitrack_example/Каскадный бит Stems/Каскадный бит (Backing Vocals).wav' }
          ]
        };

        return songs[song] || [];
      }

      async updatePlaylistCacheIndicators() {
        const songs = ['dacha', 'ulitsa', 'pukersy', 'jongler', 'kaskadny'];

        for (const song of songs) {
          const hasCached = await this.hasCachedTracksForSong(song);
          const playlistItem = document.querySelector(`[data-song="${song}"]`);

          if (playlistItem) {
            // Remove existing cache indicators
            playlistItem.querySelectorAll('.cache-indicator').forEach(indicator => indicator.remove());

            if (hasCached) {
              // Add cache indicator
              const cacheIndicator = document.createElement('span');
              cacheIndicator.className = 'cache-indicator';
              cacheIndicator.textContent = ' 💾';
              cacheIndicator.title = 'Some tracks cached';
              cacheIndicator.style.color = '#64ffda';
              cacheIndicator.style.fontSize = '0.8em';
              cacheIndicator.style.marginLeft = '5px';

              playlistItem.appendChild(cacheIndicator);
            }
          }
        }
      }

      async changeSong(song) {
        logger.log(`Changing song from ${this.currentSong} to ${song}`);

                                        // COMPLETE AUDIO RESET: Stop all audio sources regardless of isPlaying state
        logger.log('=== COMPLETE AUDIO RESET STARTING ===');

        // 1. Force stop all audio sources
        this.forceStopAllAudio();

        // 2. Disconnect all gain nodes from audio chain and clear all audio data
        this.tracks.forEach(track => {
          if (track.gainNode) {
            track.gainNode.disconnect();
            track.gainNode = null;
            logger.log(`Disconnected gain node for track ${track.id}`);
          }
          // Also clear any lingering sources
          if (track.source) {
            try {
              track.source.stop();
              logger.log(`Stopped source for track ${track.id}`);
            } catch (e) {
              logger.log(`Source for track ${track.id} already stopped`);
            }
            track.source = null;
            logger.log(`Cleared source for track ${track.id}`);
          }
          // Clear audio buffer to prevent old audio from playing
          track.audioBuffer = null;
          track.isDownloaded = false;
          logger.log(`Cleared audio buffer for track ${track.id}`);
        });

        // 3. Stop all progress updates and reset playback state
        this.stopProgressUpdate();

        // Ensure progress update is completely stopped
        if (this.progressInterval) {
          cancelAnimationFrame(this.progressInterval);
          this.progressInterval = null;
          logger.log('Progress update completely stopped');
        }

        this.isPlaying = false;
        this.currentTime = 0;
        this.duration = 0;

        // Reset progress update state completely
        this.resetProgressUpdate();

        logger.log('Playback state completely reset');

        // 4. Reset master gain connections to clean state
        if (this.masterGain) {
          this.masterGain.disconnect();
          this.masterGain.gain.value = 0.8; // Reset to default volume
          // Reconnect master gain to stereo panner and destination
          this.masterGain.connect(this.stereoPanner);
          this.stereoPanner.connect(this.audioContext.destination);
          logger.log('Master gain connections reset to clean state');
        }

                // 5. Force audio context to stop all processing
        if (this.audioContext) {
          try {
            // Suspend audio context to stop all audio processing
            if (this.audioContext.state === 'running') {
              await this.audioContext.suspend();
              logger.log('Audio context suspended to stop all audio');
            }

            // Create multiple silent buffers to force stop any lingering audio
            for (let i = 0; i < 5; i++) {
              const silentBuffer = this.audioContext.createBuffer(2, 1, 22050);
              const silentSource = this.audioContext.createBufferSource();
              silentSource.buffer = silentBuffer;
              silentSource.connect(this.audioContext.destination);
              silentSource.start();
              silentSource.stop();
            }
            logger.log('Forced audio context cleanup with multiple silent buffers');

            // Small delay to ensure audio processing stops
            await new Promise(resolve => setTimeout(resolve, 50));
          } catch (e) {
            logger.log('Audio context cleanup failed:', e);
          }
        }

        logger.log('=== COMPLETE AUDIO RESET COMPLETED ===');

                // Reset all playback state
        this.currentSong = song;
        this.duration = 0;

        // Clear any existing progress
        this.stopProgressUpdate();

        // COMPLETE UI RESET
        logger.log('=== COMPLETE UI RESET STARTING ===');

        // Reset play button states
        const playBtn = document.getElementById('play');
        const pauseBtn = document.getElementById('pause');
        const stopBtn = document.getElementById('stop');

        if (playBtn) {
          playBtn.classList.remove('selected', 'active');
          playBtn.disabled = true;
          logger.log('Play button reset and disabled');
        }
        if (pauseBtn) {
          pauseBtn.classList.remove('selected', 'active');
          pauseBtn.disabled = true;
          logger.log('Pause button reset and disabled');
        }
        if (stopBtn) {
          stopBtn.disabled = true;
          logger.log('Stop button disabled');
        }

        // Reset progress bar
        const progressFill = document.getElementById('main-progress-fill');
        const progressHandle = document.getElementById('main-progress-handle');
        if (progressFill) {
          progressFill.style.width = '0%';
          logger.log('Progress bar reset to 0%');
        } else {
          logger.error('Progress fill element not found during reset');
        }
        if (progressHandle) {
          progressHandle.style.left = '0%';
          logger.log('Progress handle reset to 0%');
        } else {
          logger.error('Progress handle element not found during reset');
        }

        // Force update progress to ensure UI is synchronized
        this.updateProgress();
        logger.log('Progress UI forced update after reset');

        // Validate progress state after reset
        logger.log(`Progress state validation: currentTime=${this.currentTime}, duration=${this.duration}, isPlaying=${this.isPlaying}`);
        if (this.currentTime !== 0) {
          logger.warn('Current time not properly reset to 0');
          this.currentTime = 0;
        }

        // Reset time display
        const currentTimeElement = document.getElementById('currentTime');
        if (currentTimeElement) {
          currentTimeElement.textContent = '0:00';
          logger.log('Time display reset to 0:00');
        }

        // Reset download all button
        const downloadAllBtn = document.getElementById('downloadAll');
        if (downloadAllBtn) {
          downloadAllBtn.classList.remove('downloading', 'downloaded', 'active');
          downloadAllBtn.disabled = false;
          downloadAllBtn.innerHTML = '⬇';
          downloadAllBtn.title = 'Download all tracks';
          logger.log('Download all button reset');
        }

        logger.log('=== COMPLETE UI RESET COMPLETED ===');

        // Store current track states before clearing
        const trackStates = new Map();
        this.tracks.forEach(track => {
          trackStates.set(track.id, {
            isDownloaded: track.isDownloaded,
            isMuted: track.isMuted,
            isSoloed: track.isSoloed,
            volume: track.volume,
            audioBuffer: track.audioBuffer
          });
        });

        // Clear current tracks but preserve states
        logger.log('Clearing all track references and audio data');
        this.tracks.forEach(track => {
          // Ensure all audio sources are stopped and disconnected
          if (track.source) {
            try {
              track.source.stop();
              logger.log(`Stopped source for track ${track.id} during cleanup`);
            } catch (e) {
              logger.log(`Source for track ${track.id} already stopped during cleanup`);
            }
          }
          if (track.gainNode) {
            track.gainNode.disconnect();
            logger.log(`Disconnected gain node for track ${track.id} during cleanup`);
          }
        });

        this.tracks = [];
        this.soloedTracks.clear();
        logger.log('All track references cleared');

        // Reset all effects to ensure clean audio chain
        Object.keys(this.effects).forEach(effectType => {
          if (this.effects[effectType].active) {
            logger.log(`Disabling effect ${effectType} during song change`);
            this.disableEffect(effectType);
          }
        });

        // Update simple UI
        const songTitle = document.getElementById('currentSongTitle');
        if (songTitle) {
          songTitle.textContent = this.getSongDisplayName(song);
        }

        // Update playlist selection
        document.querySelectorAll('.track-item').forEach((item) => {
          if (item.dataset.song === song) {
            item.classList.add('current');
          } else {
            item.classList.remove('current');
          }
        });

                  // Store track states for restoration
          this.pendingTrackStates = trackStates;

          // Load new tracks
          this.loadTracks();

        // Ensure play controls are disabled until tracks are downloaded
        this.setPlayControlsEnabled(false);

        // Resume audio context after loading new tracks
        if (this.audioContext && this.audioContext.state === 'suspended') {
          try {
            await this.audioContext.resume();
            logger.log('Audio context resumed after song change');
          } catch (e) {
            logger.log('Failed to resume audio context:', e);
          }
        }

        logger.log(`Song changed to ${song}, all states reset`);
      }

      resetAllTrackControls() {
        // Reset all track-specific controls to their initial state
        this.tracks.forEach(track => {
          if (track.element) {
            // Reset mute/solo buttons
            const muteBtn = track.element.querySelector('[data-action="mute"]');
            const soloBtn = track.element.querySelector('[data-action="solo"]');
            const volumeSlider = track.element.querySelector('.track-volume');

            if (muteBtn) {
              muteBtn.disabled = true;
              muteBtn.classList.remove('muted');
            }
            if (soloBtn) {
              soloBtn.disabled = true;
              soloBtn.classList.remove('active');
            }
            if (volumeSlider) {
              volumeSlider.disabled = true;
              volumeSlider.value = 80; // Reset to default volume
            }

            // Reset track states
            track.isMuted = false;
            track.isSoloed = false;
            track.volume = 0.8;
            track.isDownloaded = false;
            track.audioBuffer = null;
            track.source = null;
            track.gainNode = null;
          }
        });

        logger.log('All track controls reset to initial state');
      }

      restoreTrackStates() {
        if (!this.pendingTrackStates) return;

        logger.log('Restoring track states from previous song');

        this.tracks.forEach(track => {
          const savedState = this.pendingTrackStates.get(track.id);
          if (savedState) {
            // Restore track properties
            track.isMuted = savedState.isMuted;
            track.isSoloed = savedState.isSoloed;
            track.volume = savedState.volume;

            // If track was downloaded, restore audio buffer and mark as downloaded
            if (savedState.isDownloaded && savedState.audioBuffer) {
              track.audioBuffer = savedState.audioBuffer;
              track.isDownloaded = true;

              // Create gain node and restore audio setup
              track.gainNode = this.audioContext.createGain();
              track.gainNode.gain.value = track.volume;
              track.gainNode.connectedToMaster = true;
              track.gainNode.connect(this.masterGain);

              // Generate waveform
              const trackData = this.getSongData().find((_, index) => `track-${index}` === track.id);
              if (trackData) {
                this.generateWaveform(track, trackData.color);
              }

              // Enable controls for this track
              this.enableTrackControls(track.id);

              // Update UI to show downloaded state
              const trackElement = track.element;
              if (trackElement) {
                const downloadStatus = trackElement.querySelector('.download-status');
                if (downloadStatus && track.audioBuffer) {
                  const duration = track.audioBuffer.duration;
                  const minutes = Math.floor(duration / 60);
                  const seconds = Math.floor(duration % 60);
                  downloadStatus.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                  downloadStatus.style.color = '#64ffda';
                }

                // Hide loading overlay and show waveform
                this.hideTrackLoadingOverlay(track.id);

                                                // IMMEDIATE UI UPDATE: Hide placeholder, show waveform, hide download
                const placeholder = trackElement.querySelector('.placeholder-waveform');
                if (placeholder) {
                  placeholder.style.display = 'none';
                  logger.log(`✓ ${track.id}: Hidden placeholder (state restored)`);
                }

                const canvas = trackElement.querySelector('.waveform-canvas');
                if (canvas) {
                  canvas.style.display = 'block';
                  logger.log(`✓ ${track.id}: Showed waveform (state restored)`);
                }

                // Hide download overlay since track is already downloaded
                const downloadOverlay = trackElement.querySelector('.download-overlay');
                if (downloadOverlay) {
                  downloadOverlay.style.display = 'none';
                  logger.log(`✓ ${track.id}: Hidden download overlay (state restored)`);
                }
              }

              logger.log(`✓ Track ${track.id} restored with audio buffer`);
            }

            // Restore solo state
            if (track.isSoloed) {
              this.soloedTracks.add(track.id);
            }
          }
        });

        // Clear pending states
        this.pendingTrackStates = null;

        // Update track visibility and play button state
        this.updateTrackVisibility();
        this.updatePlayButtonState();
        this.updateDuration();

        // Ensure all restored tracks have proper UI state
        this.tracks.forEach(track => {
          if (track.isDownloaded && track.element) {
            // Hide placeholder for downloaded tracks
            const placeholder = track.element.querySelector('.placeholder-waveform');
            if (placeholder) {
              placeholder.style.display = 'none';
            }

            // Show waveform for downloaded tracks
            const canvas = track.element.querySelector('.waveform-canvas');
            if (canvas) {
              canvas.style.display = 'block';
            }

            // Hide download overlay for downloaded tracks
            const downloadOverlay = track.element.querySelector('.download-overlay');
            if (downloadOverlay) {
              downloadOverlay.style.display = 'none';
            }
          }
        });

        logger.log('Track states restored successfully');
      }

      getSongDisplayName(song) {
        const songNames = {
          'dacha': '🏠 На старой даче',
          'ulitsa': '🌃 Улица знает всё',
          'pukersy': '🎰 Пукерсы',
          'jongler': '🤹 Жонглёр Серёга',
          'kaskadny': '🌊 Каскадный бит'
        };
        return songNames[song] || song;
      }



      setPlayControlsEnabled(enabled) {
        logger.log(`setPlayControlsEnabled called with: ${enabled}`);
        const playBtn = document.getElementById('play');
        const pauseBtn = document.getElementById('pause');
        const stopBtn = document.getElementById('stop');

        if (playBtn) playBtn.disabled = !enabled;
        if (pauseBtn) pauseBtn.disabled = !enabled;
        if (stopBtn) stopBtn.disabled = !enabled;

        // Update visual state
        if (!enabled) {
          playBtn?.classList.add('disabled');
          pauseBtn?.classList.add('disabled');
          stopBtn?.classList.add('disabled');
        } else {
          playBtn?.classList.remove('disabled');
          pauseBtn?.classList.remove('disabled');
          stopBtn?.classList.remove('disabled');
        }

        logger.log(`Play button disabled state after setPlayControlsEnabled: ${playBtn?.disabled}`);
      }

      initializeKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
          // Ignore shortcuts when typing in input fields
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            return;
          }

          switch (e.code) {
            case 'Space':
              e.preventDefault();
              if (this.isPlaying) {
                this.pause();
              } else {
                this.play();
              }
              break;

            case 'ArrowLeft':
              e.preventDefault();
              if (e.shiftKey) {
                // Shift + Left: Jump to previous mark
                this.jumpToPreviousMark();
              } else {
                // Left: Skip backward 5 seconds
                this.skipTime(-5);
              }
              break;

            case 'ArrowRight':
              e.preventDefault();
              if (e.shiftKey) {
                // Shift + Right: Jump to next mark
                this.jumpToNextMark();
              } else {
                // Right: Skip forward 5 seconds
                this.skipTime(5);
              }
              break;

            case 'KeyK':
              e.preventDefault();
              this.addMark();
              break;
          }
        });
      }

      initializeEffectsControls() {
        // Add event listeners for effect buttons
        // Only Noise Flanger effect is available
      }

      initializeCacheControls() {
        // Add event listeners for cache control buttons
        document.getElementById('clearCacheBtn').addEventListener('click', () => this.clearAudioCache());
        document.getElementById('cacheInfoBtn').addEventListener('click', () => this.showCacheInfo());

        // Update cache status
        this.updateCacheStatus();
      }

            loadTracks() {
        logger.log('loadTracks called - preparing track structure without downloading');
        const tracksList = document.getElementById('tracksList');
        tracksList.innerHTML = '<div class="loading">Preparing tracks...</div>';

        // Disable play controls while loading
        this.setPlayControlsEnabled(false);

        try {
          const songData = this.getSongData();
          this.tracks = [];

          const tracksHTML = songData.map((track, index) => {
            const trackId = `track-${index}`;
            return this.createTrackHTML(track, trackId);
          }).join('');

          tracksList.innerHTML = tracksHTML;

                                        // Wait a bit for DOM to be ready, then initialize track structure without downloading
          setTimeout(async () => {
            for (let i = 0; i < songData.length; i++) {
              this.initializeTrackStructure(songData[i], i);
            }

            this.updateDuration();
            this.updateOscilloscope();

                        // Restore track states if available (this should happen BEFORE cache checking)
            if (this.pendingTrackStates) {
              logger.log('Restoring track states from previous song...');
              this.restoreTrackStates();
              logger.log('Track states restored, checking which tracks are already downloaded...');

              // Log the state of all tracks after restoration
              this.tracks.forEach(track => {
                logger.log(`Track ${track.id}: downloaded=${track.isDownloaded}, hasAudioBuffer=${!!track.audioBuffer}`);
              });
            }

                    // Check for cached tracks and render them (check ALL tracks after cache clearing)
        logger.log('Starting cache check for all tracks...');
        await this.checkAndRenderCachedTracks();

            // Don't enable play controls here - let updatePlayButtonState handle it
            logger.log('About to update play button state...');
            this.updatePlayButtonState();
            logger.log('Play button state updated');
            this.updateCacheStatus();

            // Update cache indicators for all songs after tracks are loaded
            this.updatePlaylistCacheIndicators();

                    // Resume audio context if it was suspended during song change
        if (this.audioContext && this.audioContext.state === 'suspended') {
          this.audioContext.resume().then(() => {
            logger.log('Audio context resumed after song change');
          }).catch(e => {
            logger.log('Failed to resume audio context after song change:', e);
          });
        }

        // Ensure audio context is in a clean state
        if (this.audioContext && this.audioContext.state === 'running') {
          logger.log('Audio context is running and ready for new tracks');
        }

        // Ensure master gain is properly connected for new tracks
        if (this.masterGain && this.stereoPanner) {
          this.masterGain.disconnect();
          this.masterGain.connect(this.stereoPanner);
          this.stereoPanner.connect(this.audioContext.destination);
          logger.log('Master gain reconnected for new tracks');
        }

        // Placeholder cleanup is now handled in checkAndRenderCachedTracks
        // No need for redundant cleanup here
          }, 100);

          logger.log('Track structure preparation completed');
        } catch (error) {
          logger.log('Failed to load tracks:', error);
          tracksList.innerHTML = '<div class="error">Failed to load tracks. Please try again.</div>';
          // Re-enable controls even on error
          this.setPlayControlsEnabled(true);
        }
      }

                  getSongData() {
        const songs = {
          ulitsa: [
            { name: 'Drums', icon: '🥁', color: '#4caf50', file: '/pages/20250821113700_suno_multitrack_example/Улица знает всё Stems/Улица знает всё (Drums).wav' },
            { name: 'Bass', icon: '🎸', color: '#ff9800', file: '/pages/20250821113700_suno_multitrack_example/Улица знает всё Stems/Улица знает всё (Bass).wav' },
            { name: 'Synth', icon: '🎹', color: '#2196f3', file: '/pages/20250821113700_suno_multitrack_example/Улица знает всё Stems/Улица знает всё (Synth).wav' }
          ],
          dacha: [
            { name: 'Vocals', icon: '🎤', color: '#ff69b4', file: '/pages/20250821113700_suno_multitrack_example/На старой даче Stems/На старой даче (Vocals).wav' },
            { name: 'Drums', icon: '🥁', color: '#4caf50', file: '/pages/20250821113700_suno_multitrack_example/На старой даче Stems/На старой даче (Drums).wav' },
            { name: 'Bass', icon: '🎸', color: '#ff9800', file: '/pages/20250821113700_suno_multitrack_example/На старой даче Stems/На старой даче (Bass).wav' },
            { name: 'Synth', icon: '🎹', color: '#2196f3', file: '/pages/20250821113700_suno_multitrack_example/На старой даче Stems/На старой даче (Synth).wav' }
          ],
          pukersy: [
            { name: 'Vocals', icon: '🎤', color: '#ff69b4', file: '/pages/20250821113700_suno_multitrack_example/Пукерсы Stems/Пукерсы (Vocals).wav' },
            { name: 'Synth', icon: '🎹', color: '#2196f3', file: '/pages/20250821113700_suno_multitrack_example/Пукерсы Stems/Пукерсы (Synth).wav' },
            { name: 'Percussion', icon: '🥁', color: '#ff9800', file: '/pages/20250821113700_suno_multitrack_example/Пукерсы Stems/Пукерсы (Percussion).wav' },
            { name: 'FX', icon: '🎛️', color: '#9c27b0', file: '/pages/20250821113700_suno_multitrack_example/Пукерсы Stems/Пукерсы (FX).wav' },
            { name: 'Drums', icon: '🥁', color: '#4caf50', file: '/pages/20250821113700_suno_multitrack_example/Пукерсы Stems/Пукерсы (Drums).wav' },
            { name: 'Bass', icon: '🎸', color: '#ff9800', file: '/pages/20250821113700_suno_multitrack_example/Пукерсы Stems/Пукерсы (Bass).wav' }
          ],
          jongler: [
            { name: 'Vocals', icon: '🎤', color: '#ff69b4', file: '/pages/20250821113700_suno_multitrack_example/Жонглёр Серёга Stems/Жонглёр Серёга (Vocals).wav' },
            { name: 'Synth', icon: '🎹', color: '#2196f3', file: '/pages/20250821113700_suno_multitrack_example/Жонглёр Серёга Stems/Жонглёр Серёга (Synth).wav' },
            { name: 'FX', icon: '🎛️', color: '#9c27b0', file: '/pages/20250821113700_suno_multitrack_example/Жонглёр Серёга Stems/Жонглёр Серёга (FX).wav' },
            { name: 'Drums', icon: '🥁', color: '#4caf50', file: '/pages/20250821113700_suno_multitrack_example/Жонглёр Серёга Stems/Жонглёр Серёга (Drums).wav' },
            { name: 'Bass', icon: '🎸', color: '#ff9800', file: '/pages/20250821113700_suno_multitrack_example/Жонглёр Серёга Stems/Жонглёр Серёга (Bass).wav' },
            { name: 'Backing Vocals', icon: '🎤', color: '#e91e63', file: '/pages/20250821113700_suno_multitrack_example/Жонглёр Серёга Stems/Жонглёр Серёга (Backing Vocals).wav' }
          ],
          kaskadny: [
            { name: 'Vocals', icon: '🎤', color: '#ff69b4', file: '/pages/20250821113700_suno_multitrack_example/Каскадный бит Stems/Каскадный бит (Vocals).wav' },
            { name: 'Synth', icon: '🎹', color: '#2196f3', file: '/pages/20250821113700_suno_multitrack_example/Каскадный бит Stems/Каскадный бит (Synth).wav' },
            { name: 'Percussion', icon: '🥁', color: '#ff9800', file: '/pages/20250821113700_suno_multitrack_example/Каскадный бит Stems/Каскадный бит (Percussion).wav' },
            { name: 'Keyboard', icon: '🎹', color: '#00bcd4', file: '/pages/20250821113700_suno_multitrack_example/Каскадный бит Stems/Каскадный бит (Keyboard).wav' },
            { name: 'FX', icon: '🎛️', color: '#9c27b0', file: '/pages/20250821113700_suno_multitrack_example/Каскадный бит Stems/Каскадный бит (FX).wav' },
            { name: 'Drums', icon: '🥁', color: '#4caf50', file: '/pages/20250821113700_suno_multitrack_example/Каскадный бит Stems/Каскадный бит (Drums).wav' },
            { name: 'Bass', icon: '🎸', color: '#ff9800', file: '/pages/20250821113700_suno_multitrack_example/Каскадный бит Stems/Каскадный бит (Bass).wav' },
            { name: 'Backing Vocals', icon: '🎤', color: '#e91e63', file: '/pages/20250821113700_suno_multitrack_example/Каскадный бит Stems/Каскадный бит (Backing Vocals).wav' }
          ]
        };

        return songs[this.currentSong] || [];
      }

      createTrackHTML(track, trackId) {
        const iconClass = track.name.toLowerCase().includes('vocals') ? 'vocals' :
                         track.name.toLowerCase().includes('drums') ? 'drums' :
                         track.name.toLowerCase().includes('bass') ? 'bass' :
                         track.name.toLowerCase().includes('percussion') ? 'drums' :
                         track.name.toLowerCase().includes('keyboard') ? 'synth' :
                         track.name.toLowerCase().includes('fx') ? 'synth' : 'synth';

        return `
          <div class="track" data-track-id="${trackId}">
            <div class="track-meta">
              <div class="track-icon ${iconClass}">${track.icon}</div>
              <div class="track-info">
                <div class="track-name">${track.name}</div>

              </div>
            </div>
            <div class="track-waveform" data-track-id="${trackId}">
              <div class="download-overlay" id="download-${trackId}">
                <button class="track-download-btn" data-track-id="${trackId}" title="Download track">
                  <span class="download-icon">⬇</span>
                  <span class="download-text">Download</span>
                </button>
                <div class="loading-overlay" id="loading-${trackId}" style="display: none;">
                  <div class="loading-spinner"></div>
                  <div class="loading-text">Downloading...</div>
                  <div class="loading-progress">
                    <div class="progress-bar">
                      <div class="progress-fill" id="progress-${trackId}"></div>
                    </div>
                    <div class="progress-text" id="progress-text-${trackId}">0%</div>
                  </div>
                </div>
              </div>

              <!-- Placeholder loading waveform -->
              <div class="placeholder-waveform" id="placeholder-${trackId}">
                <div class="placeholder-bars">
                  ${Array.from({length: 20}, (_, i) =>
                    `<div class="placeholder-bar" style="height: ${20 + Math.random() * 40}%; animation-delay: ${i * 0.1}s;"></div>`
                  ).join('')}
                </div>
                <div class="placeholder-text">Checking cache...</div>
              </div>

              <canvas class="waveform-canvas" width="400" height="60" style="display: none;"></canvas>
              <div class="playhead" style="position: absolute; top: 0; left: 0%; width: 2px; height: 100%; background: #64ffda; pointer-events: none; z-index: 10;"></div>
            </div>
            <div class="track-controls">
              <div class="control-group">
                <div class="button-row">
                  <button class="track-btn" data-action="mute" title="Mute" disabled>M</button>
                  <button class="track-btn" data-action="solo" title="Solo" disabled>S</button>
                </div>
                <input type="range" class="track-volume" min="0" max="100" value="80" title="Volume" disabled>
              </div>
            </div>
          </div>
        `;
      }

      initializeTrackStructure(trackData, index) {
        const trackId = `track-${index}`;
        const trackElement = document.querySelector(`[data-track-id="${trackId}"]`);

        if (!trackElement) return;

        const track = {
          id: trackId,
          name: trackData.name,
          element: trackElement,
          audioBuffer: null,
          source: null,
          gainNode: null,
          isMuted: false,
          isSoloed: false,
          volume: 0.8,
          isDownloaded: false
        };

        this.tracks.push(track);

        // Show loader initially while checking cache
        const placeholder = trackElement.querySelector('.placeholder-waveform');
        const downloadOverlay = trackElement.querySelector('.download-overlay');

        if (placeholder) {
          placeholder.style.display = 'flex';  // Show loader initially
        }
        if (downloadOverlay) {
          downloadOverlay.style.display = 'none';  // Hide download button initially
        }

        // Add download button event listener
        const downloadBtn = trackElement.querySelector('.track-download-btn');
        if (downloadBtn) {
          downloadBtn.addEventListener('click', () => {
            this.downloadTrack(trackData, index);
          });
        }
      }

            async downloadTrack(trackData, index) {
        const trackId = `track-${index}`;

        const track = this.tracks[index];
        if (!track) return;

        if (track.isDownloaded) return;

        const downloadBtn = track.element.querySelector('.track-download-btn');
        const downloadOverlay = track.element.querySelector('.download-overlay');
        const loadingOverlay = track.element.querySelector('.loading-overlay');

        if (downloadBtn && downloadOverlay && loadingOverlay) {
          // Show loader immediately when download is requested
          logger.log(`Track ${trackId} download requested, showing loader first`);

          // Hide download button and show loader
          downloadOverlay.style.display = 'none';
          loadingOverlay.style.display = 'flex';

          // Hide placeholder since we're processing
          const placeholder = track.element.querySelector('.placeholder-waveform');
          if (placeholder) {
            placeholder.style.display = 'none';
          }

          try {
            // Check cache first
            const cachedAudio = await this.getCachedAudio(trackData.file);

            if (cachedAudio) {
              logger.log(`Track ${trackId} found in cache, loading directly`);
              // Show loading progress for cache loading
              this.updateTrackLoadingProgress(trackId, 0, 'Loading from cache...');
              this.updateTrackLoadingProgress(trackId, 50, 'Decoding audio...');
              this.updateTrackLoadingProgress(trackId, 100, 'Processing...');

              // Load from cache
              await this.loadTrackAudio(trackData, index);

              // Hide loader and show waveform
              loadingOverlay.style.display = 'none';
              const canvas = track.element.querySelector('.waveform-canvas');
              if (canvas) {
                canvas.style.display = 'block';
              }

              // Update play button state after successful load
              this.updatePlayButtonState();
            } else {
              logger.log(`Track ${trackId} not cached, proceeding with download`);
              // Cache miss - continue with download
              downloadBtn.classList.add('downloading');
              downloadBtn.disabled = true;

              // Download the track with progress tracking
              await this.loadTrackAudio(trackData, index);

              // Hide loader and show waveform after successful download
              loadingOverlay.style.display = 'none';
              const canvas = track.element.querySelector('.waveform-canvas');
              if (canvas) {
                canvas.style.display = 'block';
              }

              // Update play button state after successful download
              this.updatePlayButtonState();
            }
          } catch (error) {
            logger.log(`Failed to process track ${trackData.name}:`, error);
            // Reset to download state on error
            downloadBtn.classList.remove('downloading');
            downloadBtn.disabled = false;
            downloadOverlay.style.display = 'flex';
            loadingOverlay.style.display = 'none';

            // Show error in loading overlay
            this.updateTrackLoadingProgress(trackId, 0, 'Download failed - click to retry');
          }
        }
      }

      async loadTrackAudio(trackData, index) {
        const trackId = `track-${index}`;
        const trackElement = document.querySelector(`[data-track-id="${trackId}"]`);

        try {
          logger.log(`Loading track audio: ${trackData.file}`);
          const filePath = trackData.file;
          logger.log(`Full file path: ${filePath}`);

          // Test if the file exists by making a HEAD request first
          try {
            const testResponse = await fetch(filePath, { method: 'HEAD' });
            logger.log(`File test response: ${testResponse.status} ${testResponse.statusText}`);
            if (!testResponse.ok) {
              throw new Error(`File not accessible: ${testResponse.status} ${testResponse.statusText}`);
            }
          } catch (testError) {
            logger.error(`File test failed: ${testError.message}`);
            throw new Error(`File not accessible: ${testError.message}`);
          }

          // Check cache first
          let arrayBuffer = await this.getCachedAudio(filePath);

          if (arrayBuffer) {
            // Cache hit - show cached status
            this.updateTrackLoadingProgress(trackId, 100, 'Loading from cache...');
          } else {
            // Cache miss - download the file
            this.updateTrackLoadingProgress(trackId, 0, 'Starting download...');

            const response = await fetch(filePath);
            logger.log(`Response status: ${response.status} ${response.statusText}`);
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            // Track download progress
            const reader = response.body.getReader();
            const contentLength = +response.headers.get('content-length');
            let receivedLength = 0;

            const chunks = [];
            while (true) {
              const { done, value } = await reader.read();

              if (done) break;

              chunks.push(value);
              receivedLength += value.length;

              // Update progress
              const progress = contentLength ? Math.round((receivedLength / contentLength) * 100) : 0;
              this.updateTrackLoadingProgress(trackId, progress, `Downloading... ${progress}%`);
            }

            // Combine chunks into array buffer
            arrayBuffer = new ArrayBuffer(receivedLength);
            const uint8Array = new Uint8Array(arrayBuffer);
            let position = 0;
            for (const chunk of chunks) {
              uint8Array.set(chunk, position);
              position += chunk.length;
            }

            // Cache the downloaded audio
            await this.setCachedAudio(filePath, arrayBuffer);
          }

          logger.log(`Audio data loaded, size: ${arrayBuffer.byteLength} bytes`);
          this.updateTrackLoadingProgress(trackId, 100, 'Decoding audio...');

          // Safari-safe decode path: try promise decode first, fall back to callback API
          const decodeWithFallback = (ctx, buf) => new Promise((resolve, reject) => {
            try {
              const maybePromise = ctx.decodeAudioData(buf, resolve, reject);
              // If decodeAudioData returns a promise (modern spec), chain it
              if (maybePromise && typeof maybePromise.then === 'function') {
                maybePromise.then(resolve).catch(reject);
              }
            } catch (e) {
              reject(e);
            }
          });
          const audioBuffer = await decodeWithFallback(this.audioContext, arrayBuffer);
          logger.log(`Audio decoded, duration: ${audioBuffer.duration}s, channels: ${audioBuffer.numberOfChannels}`);

          // Update existing track object
          const track = this.tracks[index];
          track.audioBuffer = audioBuffer;
          track.isDownloaded = true;

          logger.log(`Track ${trackId} marked as downloaded`);
          logger.log(`Track ${trackId} download status:`, track.isDownloaded);
          logger.log(`Track ${trackId} full object:`, track);

          // Verify the track is in the tracks array
          const trackIndex = this.tracks.findIndex(t => t.id === trackId);
          logger.log(`Track ${trackId} found at index ${trackIndex} in tracks array`);
          logger.log(`Tracks array length: ${this.tracks.length}`);
          logger.log(`Tracks array contents:`, this.tracks.map(t => ({ id: t.id, name: t.name, isDownloaded: t.isDownloaded })));

          // Create gain node
          track.gainNode = this.audioContext.createGain();
          track.gainNode.gain.value = track.volume;
          track.gainNode.connectedToMaster = true;

          // Connect gain node to master gain immediately
          track.gainNode.connect(this.masterGain);

          // Update download status
          const downloadStatus = trackElement.querySelector('.download-status');
          if (downloadStatus) {
            const duration = audioBuffer.duration;
            const minutes = Math.floor(duration / 60);
            const seconds = Math.floor(duration % 60);
            downloadStatus.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            downloadStatus.style.color = '#64ffda';
          }

          // Track visibility will be updated after all tracks are downloaded

          // Generate waveform
          this.generateWaveform(track, trackData.color);

          // Hide loading overlay and show waveform
          this.hideTrackLoadingOverlay(trackId);

          // Enable track controls
          this.enableTrackControls(trackId);

          // Set buffer for scatter effect if it's active
          if (this.effects.scatter.active && this.effects.scatter.node) {
            this.effects.scatter.node.setBuffer(audioBuffer);
          }

                    // Set buffer for all tracks to scatter effect
          if (this.effects.scatter.node) {
            this.effects.scatter.node.setBuffer(audioBuffer);
          }

          // IMMEDIATE UI UPDATE: Hide placeholder, show waveform, hide download
          const placeholder = trackElement.querySelector('.placeholder-waveform');
          if (placeholder) {
            placeholder.style.display = 'none';
            logger.log(`✓ ${trackId}: Hidden placeholder (download complete)`);
          }

          const canvas = trackElement.querySelector('.waveform-canvas');
          if (canvas) {
            canvas.style.display = 'block';
            logger.log(`✓ ${trackId}: Showed waveform (download complete)`);
          }

          // Hide download overlay since track is now downloaded
          const downloadOverlay = trackElement.querySelector('.download-overlay');
          if (downloadOverlay) {
            downloadOverlay.style.display = 'none';
            logger.log(`✓ ${trackId}: Hidden download overlay (download complete)`);
          }

          logger.log(`Track ${trackData.name} loaded successfully:`, track);

          // Update play button state after each track download
          this.updatePlayButtonState();

          // Update duration after track is loaded
          this.updateDuration();

        } catch (error) {
          logger.log(`Failed to load track ${trackData.name}:`, error);
          logger.log(`Track file path: ${trackData.file}`);
          logger.log(`Track index: ${index}`);
          logger.log(`Track element:`, trackElement);

          const downloadStatus = trackElement.querySelector('.download-status');
          if (downloadStatus) {
            downloadStatus.textContent = 'Download failed';
            downloadStatus.style.color = '#ff6b6b';
          }
          this.updateTrackLoadingProgress(trackId, 0, 'Error loading track');

          // Re-throw the error so it can be caught by the caller
          throw error;
        }
      }

      async downloadAllTracks() {
        const downloadBtn = document.getElementById('downloadAll');
        if (!downloadBtn) return;

        // Show downloading state
        downloadBtn.classList.add('downloading');
        downloadBtn.disabled = true;
        downloadBtn.innerHTML = '⏳';

        try {
          const songData = this.getSongData();
          const downloadPromises = [];

          // Start downloading all missing tracks directly (skip cache check)
          for (let i = 0; i < songData.length; i++) {
            const track = this.tracks[i];
            if (track && !track.isDownloaded) {
              logger.log(`Downloading missing track ${track.id} directly`);
              downloadPromises.push(this.loadTrackAudio(songData[i], i));
            } else if (track && track.isDownloaded) {
              logger.log(`Skipping track ${track.id} (already downloaded)`);
            }
          }

          // Wait for all downloads to complete
          await Promise.all(downloadPromises);

          // Update download all button state
          downloadBtn.classList.remove('downloading');
          downloadBtn.classList.add('downloaded');
          downloadBtn.innerHTML = '✓';
          downloadBtn.title = 'All tracks downloaded';

          // Update play button state
          this.updatePlayButtonState();

          // Ensure all tracks have proper volume settings
          this.updateTrackVisibility();

          // Update duration after all tracks are downloaded
          this.updateDuration();

          logger.log('All tracks downloaded successfully');
        } catch (error) {
          logger.log('Failed to download all tracks:', error);

          // Reset download all button state
          downloadBtn.classList.remove('downloading');
          downloadBtn.disabled = false;
          downloadBtn.innerHTML = '⬇';
          downloadBtn.title = 'Download all tracks';
        }
      }

                  async initializeTrack(trackData, index) {
        const trackId = `track-${index}`;
        const trackElement = document.querySelector(`[data-track-id="${trackId}"]`);

        try {
          logger.log(`Loading track: ${trackData.file}`);
          const filePath = trackData.file; // Use absolute path directly
          logger.log(`Full file path: ${filePath}`);

          // Test if the file exists by making a HEAD request first
          try {
            const testResponse = await fetch(filePath, { method: 'HEAD' });
            logger.log(`File test response: ${testResponse.status} ${testResponse.statusText}`);
            if (!testResponse.ok) {
              throw new Error(`File not accessible: ${testResponse.status} ${testResponse.statusText}`);
            }
          } catch (testError) {
            logger.error(`File test failed: ${testError.message}`);
            throw new Error(`File not accessible: ${testError.message}`);
          }

                    // Check cache first
          let arrayBuffer = await this.getCachedAudio(filePath);

          if (arrayBuffer) {
            // Cache hit - show cached status
            this.updateTrackLoadingProgress(trackId, 100, 'Loading from cache...');
          } else {
            // Cache miss - download the file
            this.updateTrackLoadingProgress(trackId, 0, 'Starting download...');

            const response = await fetch(filePath);
            logger.log(`Response status: ${response.status} ${response.statusText}`);
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            // Track download progress
            const reader = response.body.getReader();
            const contentLength = +response.headers.get('content-length');
            let receivedLength = 0;

            const chunks = [];
            while (true) {
              const { done, value } = await reader.read();

              if (done) break;

              chunks.push(value);
              receivedLength += value.length;

              // Update progress
              const progress = contentLength ? Math.round((receivedLength / contentLength) * 100) : 0;
              this.updateTrackLoadingProgress(trackId, progress, `Downloading... ${progress}%`);
            }

            // Combine chunks into array buffer
            arrayBuffer = new ArrayBuffer(receivedLength);
            const uint8Array = new Uint8Array(arrayBuffer);
            let position = 0;
            for (const chunk of chunks) {
              uint8Array.set(chunk, position);
              position += chunk.length;
            }

            // Cache the downloaded audio
            await this.setCachedAudio(filePath, arrayBuffer);
          }

                      logger.log(`Audio data loaded, size: ${arrayBuffer.byteLength} bytes`);
          this.updateTrackLoadingProgress(trackId, 100, 'Decoding audio...');

          // Safari-safe decode path: try promise decode first, fall back to callback API
          const decodeWithFallback = (ctx, buf) => new Promise((resolve, reject) => {
            try {
              const maybePromise = ctx.decodeAudioData(buf, resolve, reject);
              // If decodeAudioData returns a promise (modern spec), chain it
              if (maybePromise && typeof maybePromise.then === 'function') {
                maybePromise.then(resolve).catch(reject);
              }
            } catch (e) {
              reject(e);
            }
          });
          const audioBuffer = await decodeWithFallback(this.audioContext, arrayBuffer);
                      logger.log(`Audio decoded, duration: ${audioBuffer.duration}s, channels: ${audioBuffer.numberOfChannels}`);

                    // Update existing track object
          const track = this.tracks[index];
          track.audioBuffer = audioBuffer;
          track.isDownloaded = true;

          logger.log(`Track ${trackId} marked as downloaded`);
          logger.log(`Track ${trackId} download status:`, track.isDownloaded);
          logger.log(`Track ${trackId} full object:`, track);

          // Verify the track is in the tracks array
          const trackIndex = this.tracks.findIndex(t => t.id === trackId);
          logger.log(`Track ${trackId} found at index ${trackIndex} in tracks array`);
          logger.log(`Tracks array length: ${this.tracks.length}`);
          logger.log(`Tracks array contents:`, this.tracks.map(t => ({ id: t.id, name: t.name, isDownloaded: t.isDownloaded })));

          // Create gain node
          track.gainNode = this.audioContext.createGain();
          track.gainNode.gain.value = track.volume;
          track.gainNode.connectedToMaster = true;

          // Connect gain node to master gain immediately
          track.gainNode.connect(this.masterGain);

          // Update download status
          const downloadStatus = trackElement.querySelector('.download-status');
          if (downloadStatus) {
            const duration = audioBuffer.duration;
            const minutes = Math.floor(duration / 60);
            const seconds = Math.floor(duration % 60);
            downloadStatus.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            downloadStatus.style.color = '#64ffda';
          }

          // Update track visibility to ensure proper volume settings
          this.updateTrackVisibility();

                    // Generate waveform
          this.generateWaveform(track, trackData.color);

          // Hide loading overlay and show waveform
          this.hideTrackLoadingOverlay(trackId);

          // Enable track controls
          this.enableTrackControls(trackId);

          // Set buffer for scatter effect if it's active
          if (this.effects.scatter.active && this.effects.scatter.node) {
            this.effects.scatter.node.setBuffer(audioBuffer);
          }

          // Set buffer for all tracks to scatter effect
          if (this.effects.scatter.node) {
            this.effects.scatter.node.setBuffer(audioBuffer);
          }

          logger.log(`Track ${trackData.name} loaded successfully:`, track);

                    // Update play button state after each track download
          this.updatePlayButtonState();

        } catch (error) {
          logger.log(`Failed to load track ${trackData.name}:`, error);
          logger.log(`Track file path: ${trackData.file}`);
          logger.log(`Track index: ${index}`);
          logger.log(`Track element:`, trackElement);

          const downloadStatus = trackElement.querySelector('.download-status');
          if (downloadStatus) {
            downloadStatus.textContent = 'Download failed';
            downloadStatus.style.color = '#ff6b6b';
          }
          this.updateTrackLoadingProgress(trackId, 0, 'Error loading track');

          // Re-throw the error so it can be caught by the caller
          throw error;
        }
      }

      updateTrackLoadingProgress(trackId, progress, text) {
        // Find the track element first
        const trackElement = document.querySelector(`[data-track-id="${trackId}"]`);
        if (!trackElement) {
          logger.warn(`Track element not found for ${trackId}`);
          return;
        }

        // Use the correct ID selectors based on the track HTML structure
        const progressFill = document.getElementById(`progress-${trackId}`);
        const progressText = document.getElementById(`progress-text-${trackId}`);
        const loadingText = trackElement.querySelector('.loading-text');
        const loadingOverlay = document.getElementById(`loading-${trackId}`);
        const downloadBtn = trackElement.querySelector('.track-download-btn');

        // Show loading overlay when progress starts
        if (loadingOverlay && progress > 0) {
          loadingOverlay.style.display = 'flex';
        }

        // Hide download button when loading starts
        if (downloadBtn && progress > 0) {
          downloadBtn.style.display = 'none';
        }

        // Update progress bar
        if (progressFill) {
          progressFill.style.width = `${progress}%`;
        }

        // Update progress text
        if (progressText) {
          progressText.textContent = `${progress}%`;
        }

        // Update loading text
        if (loadingText) {
          loadingText.textContent = text;
        }

        logger.log(`Progress update for ${trackId}: ${progress}% - ${text}`);
      }

      hideTrackLoadingOverlay(trackId) {
        // Find the track element first
        const trackElement = document.querySelector(`[data-track-id="${trackId}"]`);
        if (!trackElement) {
          logger.warn(`Track element not found for ${trackId}`);
          return;
        }

        const loadingOverlay = document.getElementById(`loading-${trackId}`);
        const canvas = trackElement.querySelector('.waveform-canvas');
        const downloadBtn = trackElement.querySelector('.track-download-btn');

        if (loadingOverlay) {
          loadingOverlay.style.display = 'none';
        }
        if (canvas) {
          canvas.style.display = 'block';
        }
        if (downloadBtn) {
          downloadBtn.style.display = 'inline-flex';
        }

        logger.log(`Loading overlay hidden for ${trackId}, showing waveform and download button`);
      }

      enableTrackControls(trackId) {
        logger.log(`enableTrackControls called for ${trackId}`);
        const trackElement = document.querySelector(`[data-track-id="${trackId}"]`);
        if (trackElement) {
          const muteBtn = trackElement.querySelector('[data-action="mute"]');
          const soloBtn = trackElement.querySelector('[data-action="solo"]');
          const volumeSlider = trackElement.querySelector('.track-volume');

          logger.log(`Found controls for ${trackId}:`, { muteBtn: !!muteBtn, soloBtn: !!soloBtn, volumeSlider: !!volumeSlider });

          if (muteBtn) muteBtn.disabled = false;
          if (soloBtn) soloBtn.disabled = false;
          if (volumeSlider) volumeSlider.disabled = false;

          // Add event listeners for this track
          this.setupTrackEventListenersForTrack(trackId);

          logger.log(`Controls enabled for ${trackId}`);
        } else {
          logger.log(`Track element not found for ${trackId}`);
        }
      }

      setupTrackEventListenersForTrack(trackId) {
        const track = this.tracks.find(t => t.id === trackId);
        if (!track || !track.element) return;

        const element = track.element;

        // Mute button
        const muteBtn = element.querySelector('[data-action="mute"]');
        if (muteBtn) {
          muteBtn.addEventListener('click', () => {
            this.toggleMute(track);
          });
        }

        // Solo button
        const soloBtn = element.querySelector('[data-action="solo"]');
        if (soloBtn) {
          soloBtn.addEventListener('click', () => {
            this.toggleSolo(track);
          });
        }

        // Volume slider
        const volumeSlider = element.querySelector('.track-volume');
        if (volumeSlider) {
          volumeSlider.addEventListener('input', (e) => {
            this.setTrackVolume(track, e.target.value / 100);
          });

          // Add sticky positions for track volume slider
          volumeSlider.addEventListener('change', (e) => {
            const value = parseInt(e.target.value);
            const stickyPositions = [0, 25, 50, 75, 100];
            const closest = stickyPositions.reduce((prev, curr) => {
              return (Math.abs(curr - value) < Math.abs(prev - value) ? curr : prev);
            });

            if (Math.abs(closest - value) <= 5) { // 5% tolerance
              e.target.value = closest;
              this.setTrackVolume(track, closest / 100);
            }
          });
        }

        // Waveform click
        const wf = element.querySelector('.track-waveform');
        if (wf) {
          // Click & drag seek on waveform (mobile-friendly)
          let seeking = false;
          let lastClickSeekTime = 0;

          // Store reference to 'this' for use in event handlers
          const self = this;

          const seekEvent = (event) => {
            const now = Date.now();
            // Prevent rapid seeking (debounce)
            if (now - lastClickSeekTime < 100) {
              return;
            }
            lastClickSeekTime = now;

            const clientX = event.changedTouches ? event.changedTouches[0].clientX : event.clientX;
            const rect = wf.getBoundingClientRect();
            const x = Math.max(0, Math.min(clientX - rect.left, rect.width));
            const percentage = x / rect.width;

            // Use the main duration for consistency
            const seekTime = percentage * self.duration;

            logger.log(`Waveform seek: x=${x}, width=${rect.width}, percentage=${(percentage*100).toFixed(1)}%, time=${seekTime.toFixed(2)}s`);
            logger.log(`Current time before waveform seek: ${self.currentTime}s, duration: ${self.duration}s`);

            self.seekToTime(seekTime);
          };

          // Use mousedown for immediate seeking, prevent double events
          wf.addEventListener('mousedown', (e) => {
            e.preventDefault(); // Prevent default to avoid conflicts
            seeking = true;
            seekEvent(e);
          });

          // Throttle mousemove to prevent excessive seeking during drag
          let lastSeekTime = 0;
          wf.addEventListener('mousemove', (e) => {
            if (seeking) {
              const now = Date.now();
              if (now - lastSeekTime > 100) { // Increased to 100ms for smoother seeking
                seekEvent(e);
                lastSeekTime = now;
              }
            }
          });
          wf.addEventListener('mouseup', (e) => {
            e.preventDefault();
            seeking = false;
          });
          wf.addEventListener('mouseleave', () => { seeking = false; });

          // Touch events for mobile with better handling
          wf.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent default touch behavior
            seeking = true;
            seekEvent(e);
          }, { passive: false });

          // Throttle touchmove as well
          let lastTouchSeekTime = 0;
          wf.addEventListener('touchmove', (e) => {
            if (seeking) {
              e.preventDefault(); // Prevent scrolling during seek
              const now = Date.now();
              if (now - lastTouchSeekTime > 100) { // Increased to 100ms for smoother seeking
                seekEvent(e);
                lastTouchSeekTime = now;
              }
            }
          }, { passive: false });
          wf.addEventListener('touchend', (e) => {
            e.preventDefault();
            seeking = false;
          });
        }

        logger.log(`Event listeners set up for track ${trackId}`);
      }

      updateTrackControls(trackId, enabled) {
        if (enabled) {
          this.enableTrackControls(trackId);
        }
      }

                  updatePlayButtonState() {
        const playBtn = document.getElementById('play');
        const pauseBtn = document.getElementById('pause');
        const stopBtn = document.getElementById('stop');

        const hasDownloadedTracks = this.tracks.some(track => track.isDownloaded);

        logger.log(`updatePlayButtonState: hasDownloadedTracks=${hasDownloadedTracks}, total tracks=${this.tracks.length}`);
        this.tracks.forEach(track => {
          logger.log(`Track ${track.id}: isDownloaded=${track.isDownloaded}, hasAudioBuffer=${!!track.audioBuffer}`);
        });

        if (playBtn) playBtn.disabled = !hasDownloadedTracks;
        if (pauseBtn) pauseBtn.disabled = !hasDownloadedTracks;
        if (stopBtn) stopBtn.disabled = !hasDownloadedTracks;

        // Update visual state
        if (!hasDownloadedTracks) {
          playBtn?.classList.add('disabled');
          pauseBtn?.classList.add('disabled');
          stopBtn?.classList.add('disabled');
          logger.log('Play controls disabled - no downloaded tracks');
        } else {
          playBtn?.classList.remove('disabled');
          pauseBtn?.classList.remove('disabled');
          stopBtn?.classList.remove('disabled');
          logger.log('Play controls enabled - tracks available');
        }
      }

      // Audio caching methods
      async getCachedAudio(url) {
        const cacheKey = this.generateCacheKey(url);
        const cached = this.audioCache.get(cacheKey);

        if (cached && Date.now() - cached.timestamp < this.cacheExpiry) {
          logger.log(`Audio cache hit for: ${url}`);
          return cached.arrayBuffer;
        }

        // Check IndexedDB for persistent cache
        const indexedDBCache = await this.getIndexedDBCache(url);
        if (indexedDBCache) {
          logger.log(`IndexedDB cache hit for: ${url}`);
          this.audioCache.set(cacheKey, {
            arrayBuffer: indexedDBCache,
            timestamp: Date.now()
          });
          return indexedDBCache;
        }

        logger.log(`Audio cache miss for: ${url}`);
        return null;
      }

      async setCachedAudio(url, arrayBuffer) {
        const cacheKey = this.generateCacheKey(url);

        // Store in memory cache
        this.audioCache.set(cacheKey, {
          arrayBuffer: arrayBuffer,
          timestamp: Date.now()
        });

        // Store in IndexedDB for persistence
        await this.setIndexedDBCache(url, arrayBuffer);

        logger.log(`Audio cached for: ${url}`);
      }

      generateCacheKey(url) {
        // Create a simple hash for the URL
        let hash = 0;
        for (let i = 0; i < url.length; i++) {
          const char = url.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash; // Convert to 32-bit integer
        }
        return `audio_${Math.abs(hash)}`;
      }

      async getIndexedDBCache(url) {
        return new Promise((resolve) => {
          if (!('indexedDB' in window)) {
            resolve(null);
            return;
          }

          const request = indexedDB.open('AudioCache', 1);

          request.onerror = () => resolve(null);

          request.onsuccess = (event) => {
            const db = event.target.result;
            const transaction = db.transaction(['audio'], 'readonly');
            const store = transaction.objectStore('audio');
            const getRequest = store.get(url);

            getRequest.onsuccess = () => {
              if (getRequest.result) {
                resolve(getRequest.result.arrayBuffer);
              } else {
                resolve(null);
              }
            };

            getRequest.onerror = () => resolve(null);
          };

          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains('audio')) {
              db.createObjectStore('audio', { keyPath: 'url' });
            }
          };
        });
      }

      async setIndexedDBCache(url, arrayBuffer) {
        return new Promise((resolve) => {
          if (!('indexedDB' in window)) {
            resolve();
            return;
          }

          const request = indexedDB.open('AudioCache', 1);

          request.onerror = () => resolve();

          request.onsuccess = (event) => {
            const db = event.target.result;
            const transaction = db.transaction(['audio'], 'readwrite');
            const store = transaction.objectStore('audio');

            const putRequest = store.put({
              url: url,
              arrayBuffer: arrayBuffer,
              timestamp: Date.now()
            });

            putRequest.onsuccess = () => resolve();
            putRequest.onerror = () => resolve();
          };

          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains('audio')) {
              db.createObjectStore('audio', { keyPath: 'url' });
            }
          };
        });
      }

                  async clearAudioCache() {
        logger.log('=== CLEARING AUDIO CACHE ===');

        // Simple memory cache clearing (this was working)
        this.audioCache.clear();
        logger.log('✓ Memory cache cleared');

        // Clear IndexedDB entries individually (more efficient than deleting entire DB)
        if ('indexedDB' in window) {
          try {
            logger.log('Clearing IndexedDB entries individually...');

            // Open the database
            const request = indexedDB.open('AudioCache', 1);

            request.onsuccess = (event) => {
              const db = event.target.result;
              const transaction = db.transaction(['audio'], 'readwrite');
              const store = transaction.objectStore('audio');

              // Get all keys (URLs) from the store
              const getAllKeysRequest = store.getAllKeys();

              getAllKeysRequest.onsuccess = () => {
                const keys = getAllKeysRequest.result;
                logger.log(`Found ${keys.length} cached entries to delete`);

                if (keys.length === 0) {
                  logger.log('✓ No cached entries found in IndexedDB');
                  db.close();
                  return;
                }

                // Delete each entry individually
                let deletedCount = 0;
                keys.forEach((key, index) => {
                  const deleteRequest = store.delete(key);
                  deleteRequest.onsuccess = () => {
                    deletedCount++;
                    logger.log(`✓ Deleted cached entry ${index + 1}/${keys.length}: ${key}`);

                    // Check if all entries have been deleted
                    if (deletedCount === keys.length) {
                      logger.log(`✓ IndexedDB cache cleared: ${deletedCount} entries deleted`);
                      db.close();
                    }
                  };
                  deleteRequest.onerror = () => {
                    logger.error(`Failed to delete cached entry: ${key}`);
                    deletedCount++;

                    // Still close DB even if some deletions failed
                    if (deletedCount === keys.length) {
                      logger.log(`IndexedDB cache partially cleared: ${deletedCount} entries processed`);
                      db.close();
                    }
                  };
                });
              };

              getAllKeysRequest.onerror = () => {
                logger.error('Failed to get cached entries from IndexedDB');
                db.close();
              };
            };

            request.onerror = () => {
              logger.error('Failed to open IndexedDB for clearing');
            };

          } catch (error) {
            logger.error('Error clearing IndexedDB entries:', error);
          }
        }

        // Reset all track states to force re-download
        if (this.tracks && this.tracks.length > 0) {
          logger.log('Resetting track states...');
          this.tracks.forEach(track => {
            if (track) {
              // Reset download state
              track.isDownloaded = false;
              track.audioBuffer = null;

              // Reset UI elements
              if (track.element) {
                const placeholder = track.element.querySelector('.placeholder-waveform');
                const canvas = track.element.querySelector('.waveform-canvas');
                const downloadOverlay = track.element.querySelector('.download-overlay');

                // Show placeholder (loading state)
                if (placeholder) {
                  placeholder.style.display = 'flex';
                  placeholder.textContent = 'Checking cache...';
                }

                // Hide waveform
                if (canvas) {
                  canvas.style.display = 'none';
                }

                // Show download button
                if (downloadOverlay) {
                  downloadOverlay.style.display = 'block';
                }

                logger.log(`✓ Track ${track.id}: Reset to downloadable state`);
              }
            }
          });

          // Update download all button state
          const downloadAllBtn = document.getElementById('downloadAll');
          if (downloadAllBtn) {
            downloadAllBtn.classList.remove('downloaded');
            downloadAllBtn.innerHTML = '⬇';
            downloadAllBtn.title = 'Download all tracks';
            downloadAllBtn.disabled = false;
          }

          // Update play button state
          this.updatePlayButtonState();

          logger.log(`✓ All ${this.tracks.length} tracks reset to downloadable state`);
        }

        // Update cache status
        this.updateCacheStatus();

                // Force cache check to show all tracks as downloadable
        if (this.tracks && this.tracks.length > 0) {
          logger.log('Forcing cache check after clearing...');
          // Force all tracks to show as downloadable
          this.tracks.forEach(track => {
            if (track && track.element) {
              const placeholder = track.element.querySelector('.placeholder-waveform');
              const canvas = track.element.querySelector('.waveform-canvas');
              const downloadOverlay = track.element.querySelector('.download-overlay');

              // Ensure download button is visible
              if (downloadOverlay) {
                downloadOverlay.style.display = 'block';
              }

              // Hide waveform
              if (canvas) {
                canvas.style.display = 'none';
              }

              // Show placeholder with "Checking cache..." text
              if (placeholder) {
                placeholder.style.display = 'flex';
                placeholder.textContent = 'Checking cache...';
              }
            }
          });

          // Update playlist cache indicators
          this.updatePlaylistCacheIndicators();
        }

        // Update cache status with current sizes
        setTimeout(async () => {
          const indexedDBSize = await this.getIndexedDBCacheSize();
          logger.log(`Cache status after clearing - Memory: ${this.audioCache.size}, IndexedDB: ${indexedDBSize}`);
        }, 100);

        logger.log('=== AUDIO CACHE CLEARED SUCCESSFULLY ===');
      }

            // Simple cache clearing - back to what was working

            updateCacheStatus() {
        const cacheStatus = document.getElementById('cacheStatus');
        if (cacheStatus) {
          const memoryCacheSize = this.audioCache.size;
          const indicator = memoryCacheSize > 0 ? '🟢' : '🔴';
          const status = memoryCacheSize > 0 ? `Cache enabled (${memoryCacheSize} tracks)` : 'Cache cleared - all tracks downloadable';
          cacheStatus.innerHTML = `<span class="cache-indicator">${indicator}</span> ${status}`;

          // Also update the cache info button if it exists
          const cacheInfoBtn = document.getElementById('cacheInfoBtn');
          if (cacheInfoBtn) {
            cacheInfoBtn.title = memoryCacheSize > 0 ? 'View cache information' : 'Cache cleared - no tracks cached';
          }
        }
      }

      // Get IndexedDB cache size for better status reporting
      async getIndexedDBCacheSize() {
        if (!('indexedDB' in window)) return 0;

        return new Promise((resolve) => {
          try {
            const request = indexedDB.open('AudioCache', 1);
            request.onsuccess = (event) => {
              const db = event.target.result;
              const transaction = db.transaction(['audio'], 'readonly');
              const store = transaction.objectStore('audio');
              const countRequest = store.count();

              countRequest.onsuccess = () => {
                db.close();
                resolve(countRequest.result);
              };

              countRequest.onerror = () => {
                db.close();
                resolve(0);
              };
            };

            request.onerror = () => {
              resolve(0);
            };
          } catch (error) {
            logger.error('Error getting IndexedDB cache size:', error);
            resolve(0);
          }
        });
      }

      async showCacheInfo() {
        const memoryCacheSize = this.audioCache.size;
        const indexedDBSize = await this.getIndexedDBCacheSize();

        this.displayCacheInfo(memoryCacheSize, indexedDBSize);
      }

      async displayCacheInfo(memorySize, indexedDBSize) {
        const totalSize = memorySize + indexedDBSize;

        // Get some sample cached URLs for more detailed info
        let sampleUrls = [];
        if (indexedDBSize > 0) {
          try {
            const request = indexedDB.open('AudioCache', 1);
            request.onsuccess = (event) => {
              const db = event.target.result;
              const transaction = db.transaction(['audio'], 'readonly');
              const store = transaction.objectStore('audio');
              const getAllRequest = store.getAll();

              getAllRequest.onsuccess = () => {
                const entries = getAllRequest.result;
                sampleUrls = entries.slice(0, 3).map(entry => {
                  const fileName = entry.url.split('/').pop();
                  return fileName || 'Unknown file';
                });

                const message = `Audio Cache Info:\n\n` +
                               `Memory Cache: ${memorySize} tracks\n` +
                               `Persistent Cache: ${indexedDBSize} tracks\n` +
                               `Total Cached: ${totalSize} tracks\n\n` +
                               `Sample Cached Files:\n${sampleUrls.map(name => `• ${name}`).join('\n')}\n\n` +
                               `Cache Expiry: 30 minutes\n` +
                               `Estimated Savings: ${totalSize * 2}MB+`;

                alert(message);
                db.close();
              };
            };
          } catch (e) {
            logger.error('Error getting cache details:', e);
          }
        }

        // Fallback message if we can't get detailed info
        if (sampleUrls.length === 0) {
          const message = `Audio Cache Info:\n\n` +
                         `Memory Cache: ${memorySize} tracks\n` +
                         `Persistent Cache: ${indexedDBSize} tracks\n` +
                         `Total Cached: ${totalSize} tracks\n\n` +
                         `Cache Expiry: 30 minutes\n` +
                         `Estimated Savings: ${totalSize * 2}MB+`;

          alert(message);
        }
      }

      async registerServiceWorker() {
        if ('serviceWorker' in navigator) {
          try {
            const registration = await navigator.serviceWorker.register('./20250821113700_suno_multitrack_example/sw.js');
            logger.log('Service Worker registered successfully:', registration);

            // Update cache status to show service worker is active
            const cacheStatus = document.getElementById('cacheStatus');
            if (cacheStatus) {
              const indicator = '🟢';
              const status = 'Cache enabled + Service Worker';
              cacheStatus.innerHTML = `<span class="cache-indicator">${indicator}</span> ${status}`;
            }
          } catch (error) {
            logger.log('Service Worker registration failed:', error);
          }
                }
      }

      updateAudioReadyState() {
        // Update UI to show audio is ready
        const playBtn = document.getElementById('play');
        if (playBtn) {
          playBtn.classList.add('audio-ready');
          logger.log('Audio ready state updated');
        }
      }

      setKrazyLevel(level) {
        logger.log(`Setting Krazy level to: ${level}`);

        // Apply krazy level to all active effects
        Object.keys(this.effects).forEach(effectType => {
          const effect = this.effects[effectType];
          if (effect.active && effect.node && effect.node.setKrazyLevel) {
            try {
              effect.node.setKrazyLevel(level);
              logger.log(`Applied Krazy level ${level} to ${effectType} effect`);
            } catch (error) {
              logger.error(`Failed to apply Krazy level to ${effectType}:`, error);
            }
          }
        });
      }

            generateWaveform(track, color) {
        const canvas = track.element.querySelector('.waveform-canvas');
        const ctx = canvas.getContext('2d');
        const audioBuffer = track.audioBuffer;

        const data = audioBuffer.getChannelData(0);
        const step = Math.ceil(data.length / canvas.width);
        const amp = canvas.height / 2;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = color;

        // Apply smoothing to the waveform
        const smoothedData = [];
        for (let i = 0; i < canvas.width; i++) {
          let min = 1.0;
          let max = -1.0;

          for (let j = 0; j < step; j++) {
            const datum = data[(i * step) + j];
            if (datum < min) min = datum;
            if (datum > max) max = datum;
          }

          smoothedData.push({ min, max });
        }

        // Apply moving average smoothing
        const smoothingWindow = 3;
        for (let i = 0; i < canvas.width; i++) {
          let smoothMin = 0;
          let smoothMax = 0;
          let count = 0;

          for (let j = Math.max(0, i - smoothingWindow); j <= Math.min(canvas.width - 1, i + smoothingWindow); j++) {
            smoothMin += smoothedData[j].min;
            smoothMax += smoothedData[j].max;
            count++;
          }

          smoothMin /= count;
          smoothMax /= count;

          const height = Math.max(1, (smoothMax - smoothMin) * amp);
          const y = (1 + smoothMin) * amp;

          ctx.fillRect(i, y, 1, height);
        }
      }

      setupTrackEventListeners() {
        this.tracks.forEach(track => {
          const element = track.element;

          // Skip tracks that aren't downloaded yet
          if (!track.isDownloaded) return;

          // Mute button
          element.querySelector('[data-action="mute"]').addEventListener('click', () => {
            this.toggleMute(track);
          });

          // Solo button
          element.querySelector('[data-action="solo"]').addEventListener('click', () => {
            this.toggleSolo(track);
          });

          // Volume slider
          element.querySelector('.track-volume').addEventListener('input', (e) => {
            this.setTrackVolume(track, e.target.value / 100);
          });

          // Add sticky positions for track volume slider
          element.querySelector('.track-volume').addEventListener('change', (e) => {
            const value = parseInt(e.target.value);
            const stickyPositions = [0, 25, 50, 75, 100];
            const closest = stickyPositions.reduce((prev, curr) => {
              return (Math.abs(curr - value) < Math.abs(prev - value) ? curr : prev);
            });

            if (Math.abs(closest - value) <= 5) { // 5% tolerance
              e.target.value = closest;
              this.setTrackVolume(track, closest / 100);
            }
          });

          // Waveform click
          const wf = element.querySelector('.track-waveform');
          // Click & drag seek on waveform (mobile-friendly)
          let seeking = false;
          let lastClickSeekTime = 0;

          // Store reference to 'this' for use in event handlers
          const self = this;

          const seekEvent = (event) => {
            const now = Date.now();
            // Prevent rapid seeking (debounce)
            if (now - lastClickSeekTime < 100) {
              return;
            }
            lastClickSeekTime = now;

            const clientX = event.changedTouches ? event.changedTouches[0].clientX : event.clientX;
            const rect = wf.getBoundingClientRect();
            const x = Math.max(0, Math.min(clientX - rect.left, rect.width));
            const percentage = x / rect.width;

            // Use the main duration for consistency
            const seekTime = percentage * self.duration;

            logger.log(`Waveform seek: x=${x}, width=${rect.width}, percentage=${(percentage*100).toFixed(1)}%, time=${seekTime.toFixed(2)}s`);
            logger.log(`Current time before waveform seek: ${self.currentTime}s, duration: ${self.duration}s`);

            self.seekToTime(seekTime);
          };

          // Use mousedown for immediate seeking, remove click to avoid double events
          wf.addEventListener('mousedown', (e) => {
            seeking = true;
            seekEvent(e);
          });

          // Throttle mousemove to prevent excessive seeking during drag
          let lastSeekTime = 0;
          wf.addEventListener('mousemove', (e) => {
            if (seeking) {
              const now = Date.now();
              if (now - lastSeekTime > 50) { // Only seek every 50ms during drag
                seekEvent(e);
                lastSeekTime = now;
              }
            }
          });
          wf.addEventListener('mouseup', () => { seeking = false; });
          wf.addEventListener('mouseleave', () => { seeking = false; });

          // Touch events for mobile
          wf.addEventListener('touchstart', (e) => {
            seeking = true;
            seekEvent(e);
          }, { passive: true });

          // Throttle touchmove as well
          let lastTouchSeekTime = 0;
          wf.addEventListener('touchmove', (e) => {
            if (seeking) {
              const now = Date.now();
              if (now - lastTouchSeekTime > 50) { // Only seek every 50ms during touch drag
                seekEvent(e);
                lastTouchSeekTime = now;
              }
            }
          }, { passive: true });
          wf.addEventListener('touchend', () => { seeking = false; });
        });
      }

      toggleMute(track) {
        track.isMuted = !track.isMuted;
        const btn = track.element.querySelector('[data-action="mute"]');

        if (track.isMuted) {
          btn.classList.add('muted');
          track.gainNode.gain.value = 0;
        } else {
          btn.classList.remove('muted');
          track.gainNode.gain.value = track.volume;
        }
      }

      toggleSolo(track) {
        track.isSoloed = !track.isSoloed;
        const btn = track.element.querySelector('[data-action="solo"]');

        if (track.isSoloed) {
          this.soloedTracks.add(track.id);
          btn.classList.add('active');
        } else {
          this.soloedTracks.delete(track.id);
          btn.classList.remove('active');
        }

        this.updateTrackVisibility();
      }

                  updateTrackVisibility() {
        logger.log('updateTrackVisibility called');
        this.tracks.forEach(track => {
          // Only update tracks that have gain nodes
          if (!track.gainNode) return;

          let newVolume = 0;
          if (this.soloedTracks.size > 0) {
            // Some tracks are soloed
            if (track.isSoloed) {
              newVolume = track.volume;
            } else {
              newVolume = 0;
            }
          } else {
            // No solo tracks, respect mute state
            if (track.isMuted) {
              newVolume = 0;
            } else {
              newVolume = track.volume;
            }
          }

          track.gainNode.gain.value = newVolume;
          logger.log(`Track ${track.id} volume set to ${newVolume} (original: ${track.volume}, muted: ${track.isMuted}, soloed: ${track.isSoloed})`);
        });
      }

      setTrackVolume(track, volume) {
        track.volume = volume;
        logger.log(`Setting track ${track.id} volume to ${volume}`);

        // Only update if gain node exists
        if (!track.gainNode) return;

        if (this.soloedTracks.size > 0) {
          // Some tracks are soloed
          if (track.isSoloed) {
            track.gainNode.gain.value = volume;
          } else {
            track.gainNode.gain.value = 0;
          }
        } else {
          // No solo tracks, respect mute state
          if (track.isMuted) {
            track.gainNode.gain.value = 0;
          } else {
            track.gainNode.gain.value = volume;
          }
        }
      }



                              seekToTime(time) {
        const seekTime = Math.max(0, Math.min(time, this.duration));

        // Prevent seeking to the same time multiple times
        if (Math.abs(this.currentTime - seekTime) < 0.1) {
          logger.log(`Seek skipped: too close to current time (${this.currentTime}s -> ${seekTime}s)`);
          return;
        }

        logger.log(`Seeking to time: ${seekTime}s (was: ${this.currentTime}s)`);

        // Stop current progress update to prevent conflicts
        this.stopProgressUpdate();

        // Update current time
        this.currentTime = seekTime;

        // Always update progress and waveform playheads immediately
        this.updateProgress();
        this.updateWaveformPlayheads();

        if (this.isPlaying) {
          // Ensure audio context is running
          if (this.audioContext && this.audioContext.state === 'suspended') {
            logger.log('Audio context suspended, resuming...');
            this.audioContext.resume();
          }

          logger.log('Restarting playback after seek...');

          // Stop scatter effect temporarily during seek
          if (this.effects.scatter.active && this.effects.scatter.node) {
            this.effects.scatter.node.stopScatter();
          }

          // CRITICAL: Wait for audio restart to complete before starting progress update
          setTimeout(async () => {
            try {
              await this.restartPlayback();

                            // Small delay to ensure audio is fully started
              setTimeout(() => {
                // Restart progress update with new reference point
                this.startProgressUpdate();

                // Validate progress update state after restart
                setTimeout(() => {
                  this.validateProgressUpdateState();
                }, 50);

                // Restart scatter effect after audio restart
                setTimeout(() => {
                  if (this.effects.scatter.active && this.effects.scatter.node) {
                    this.effects.scatter.node.startScatter();
                  }
                }, 100);
              }, 100);
            } catch (error) {
              logger.error('Error during seek restart:', error);
              // Fallback: try to play again
              setTimeout(async () => {
                try {
                  await this.restartPlayback();
                  setTimeout(() => {
                    this.startProgressUpdate();
                  }, 100);
                } catch (e) {
                  logger.error('Fallback restart also failed:', e);
                }
              }, 100);
            }
          }, 100);
        } else {
          logger.log('Not playing, only updating UI');
        }
      }

                        async play() {
        logger.log('Play method called');
        if (!this.audioContext || this.tracks.length === 0) {
          logger.log('Cannot play: audioContext or tracks not ready');
          return;
        }

        logger.log('Audio context state:', this.audioContext.state);

        // iOS Safari audio context handling - COMPREHENSIVE
        if (this.audioContext.state === 'suspended') {
          logger.log('Audio context suspended, attempting to resume...');
          try {
            await this.audioContext.resume();
            logger.log('Audio context resumed successfully, state:', this.audioContext.state);
          } catch (error) {
            logger.error('Failed to resume audio context:', error);
            // Show user message for iOS
            alert('Please tap the screen to enable audio playback (iOS requirement)');
            return;
          }
        }

        // CRITICAL: Ensure audio context is fully unlocked for iOS
        if (this.audioContext.state !== 'running') {
          logger.log('Audio context not running, attempting comprehensive unlock...');

          // Try multiple unlock methods for iOS
          try {
            // Method 1: Resume audio context
            await this.audioContext.resume();
            logger.log('Audio context resumed via resume()');

            // Method 2: Create a silent buffer to force unlock
            const silentBuffer = this.audioContext.createBuffer(1, 1, 22050);
            const silentSource = this.audioContext.createBufferSource();
            silentSource.buffer = silentBuffer;
            silentSource.connect(this.audioContext.destination);
            silentSource.start();
            silentSource.stop();
            logger.log('Silent buffer created to force unlock');

            // Method 3: Small delay to ensure unlock
            await new Promise(resolve => setTimeout(resolve, 100));

            logger.log('Audio context state after unlock attempts:', this.audioContext.state);
          } catch (unlockError) {
            logger.error('Failed to unlock audio context:', unlockError);
            alert('Audio unlock failed. Please refresh the page and try again.');
            return;
          }
        }

        // Check if audio context is muted
        if (this.audioContext.state === 'running') {
          logger.log('Audio context is running, checking for mute state...');
          // Check if the destination is muted
          const destination = this.audioContext.destination;
          logger.log('Audio destination muted:', destination.muted);
          logger.log('Audio destination channelCount:', destination.channelCount);
          logger.log('Audio destination sampleRate:', destination.sampleRate);

          // iOS-specific volume and mute checks
          if (destination.muted) {
            logger.warn('iOS Audio: Destination is muted - this may prevent sound output');
            alert('🔇 Audio is muted. Please check your device volume and unmute if necessary.');
            return;
          }

          // Ensure master gain is at audible level
          if (this.masterGain && this.masterGain.gain.value < 0.1) {
            logger.warn('iOS Audio: Master gain too low, setting to audible level');
            this.masterGain.gain.value = 0.8;
          }
        }

        // Additional iOS check
        if (this.audioContext.state !== 'running') {
          logger.log('Audio context not running, current state:', this.audioContext.state);
          alert('Audio not ready. Please tap the screen to enable audio playback.');
          return;
        }

                this.isPlaying = true;
                logger.log('isPlaying set to true');

        // Update simple display
        const playBtn = document.getElementById('play');
        const pauseBtn = document.getElementById('pause');
        if (playBtn) playBtn.classList.add('selected');
        if (pauseBtn) pauseBtn.classList.remove('selected');

                // Filter only downloaded tracks
        const downloadedTracks = this.tracks.filter(track => track.isDownloaded);

        if (downloadedTracks.length === 0) {
          alert('No tracks downloaded yet. Please download tracks first.');
          this.isPlaying = false;
          return;
        }

        // CRITICAL: Ensure duration is valid before starting playback
        if (this.duration <= 0) {
          logger.log('Duration is invalid, updating before playback...');
          this.updateDuration();

          if (this.duration <= 0) {
            logger.log('Duration still invalid after update, cannot start playback');
            this.isPlaying = false;
            return;
          }
        }

        logger.log(`Starting playback with duration: ${this.duration}s`);

        downloadedTracks.forEach((track, index) => {
          logger.log(`Processing track ${index}:`, {
            id: track.id,
            name: track.name,
            hasGainNode: !!track.gainNode,
            hasAudioBuffer: !!track.audioBuffer,
            gainNodeConnected: track.gainNode?.connectedToMaster,
            volume: track.volume,
            isMuted: track.isMuted
          });

          if (track.source) {
            try {
              track.source.stop();
            } catch (e) {
              logger.log('Track source already stopped');
            }
          }

          if (!track.gainNode) {
            logger.error(`Track ${index} has no gain node!`);
            return;
          }

          if (!track.audioBuffer) {
            logger.error(`Track ${index} has no audio buffer!`);
            return;
          }

          track.source = this.audioContext.createBufferSource();
          track.source.buffer = track.audioBuffer;
          track.source.connect(track.gainNode);

          // Set onended handler to detect when source ends
          track.source.onended = () => {
            logger.log(`Track ${index} source ended naturally`);
          };

          // Keep a reference to prevent garbage collection
          logger.log(`Track ${index} source created and connected:`, {
            source: track.source,
            buffer: track.source.buffer,
            gainNode: track.gainNode
          });

          // Ensure gain node is connected to master gain (only if not already connected)
          if (track.gainNode && !track.gainNode.connectedToMaster) {
            track.gainNode.connect(this.masterGain);
            track.gainNode.connectedToMaster = true;
            logger.log(`Track ${index} gain node connected to master`);
          }

          try {
            // Start each buffer at the same offset to keep them aligned
            const offset = Math.min(this.currentTime, track.audioBuffer.duration - 0.001);
            logger.log(`Track ${index} starting with offset: ${offset}, currentTime: ${this.currentTime}, bufferDuration: ${track.audioBuffer.duration}`);
            track.source.start(0, offset);
            logger.log(`Track ${index} started successfully at offset ${offset}`);
            logger.log(`Track ${index} source details:`, {
              buffer: track.source.buffer,
              bufferDuration: track.source.buffer?.duration,
              startTime: track.source.startTime,
              playbackRate: track.source.playbackRate
            });

            // Check if source is actually playing
            setTimeout(() => {
              if (track.source && track.source.playbackState === 'playing') {
                logger.log(`Track ${index} is still playing after 100ms`);
              } else {
                logger.log(`Track ${index} stopped playing after 100ms`);
              }
            }, 100);
          } catch (error) {
            logger.log(`Failed to start track ${index}:`, error);
          }
        });

        // Ensure track volumes are set correctly before playback
        logger.log('About to call updateTrackVisibility, soloed tracks:', this.soloedTracks.size);
        this.updateTrackVisibility();

                // Debug audio context and master gain
        logger.log('Audio context state after starting tracks:', this.audioContext.state);
        logger.log('Master gain value:', this.masterGain.gain.value);
        logger.log('Master gain connected:', this.masterGain.numberOfInputs, 'inputs,', this.masterGain.numberOfInputs, 'outputs');
        logger.log('Current duration:', this.duration);
        logger.log('Current time:', this.currentTime);

        // Check if master gain is connected to destination
        logger.log('Master gain connected to destination:', this.masterGain.connectedToDestination);
        logger.log('Audio destination muted:', this.audioContext.destination.muted);

        // Check volume slider value
        const volumeSlider = document.getElementById('masterVolume');
        if (volumeSlider) {
          logger.log('Volume slider value:', volumeSlider.value);
          logger.log('Volume slider calculated gain:', volumeSlider.value / 100);
        }

        // Test beep removed to avoid interference

        this.startProgressUpdate();

        // Validate progress update state after starting
        setTimeout(() => {
          this.validateProgressUpdateState();
        }, 100);

        // Start scatter effect if active
        if (this.effects.scatter.active && this.effects.scatter.node) {
          this.effects.scatter.node.startScatter();
        }
      }

      restartPlayback() {
        logger.log(`Restarting playback from time ${this.currentTime}s`);

        // Stop current sources without resetting currentTime
        this.tracks.forEach(track => {
          if (track.source) {
            try {
              track.source.stop();
            } catch (e) {
              logger.log('Track source already stopped');
            }
            track.source = null;
          }
        });

        // Restart from current position (only downloaded tracks)
        const downloadedTracks = this.tracks.filter(track => track.isDownloaded);

        downloadedTracks.forEach((track, index) => {
          track.source = this.audioContext.createBufferSource();
          track.source.buffer = track.audioBuffer;
          track.source.connect(track.gainNode);

          // Ensure gain node is connected to master gain (only if not already connected)
          if (track.gainNode && !track.gainNode.connectedToMaster) {
            track.gainNode.connect(this.masterGain);
            track.gainNode.connectedToMaster = true;
          }

          try {
            const offset = Math.min(this.currentTime, track.audioBuffer.duration - 0.001);
            track.source.start(0, offset);
          } catch (e) {
            logger.error(`Failed to restart track ${index}:`, e);
          }
        });
      }

            pause() {
        this.isPlaying = false;

        // Update simple display
        const playBtn = document.getElementById('play');
        const pauseBtn = document.getElementById('pause');
        if (playBtn) playBtn.classList.remove('selected');
        if (pauseBtn) pauseBtn.classList.add('selected');

        this.tracks.forEach(track => {
          if (track.source) {
            track.source.stop();
            track.source = null;
          }
        });

        this.stopProgressUpdate();

        // Stop scatter effect if active
        if (this.effects.scatter.active && this.effects.scatter.node) {
          this.effects.scatter.node.stopScatter();
        }
      }

            stop() {
        this.isPlaying = false;
        this.currentTime = 0;

        // Update simple display
        const playBtn = document.getElementById('play');
        const pauseBtn = document.getElementById('pause');
        if (playBtn) playBtn.classList.remove('selected');
        if (pauseBtn) pauseBtn.classList.remove('selected');

        this.tracks.forEach(track => {
          if (track.source) {
            track.source.stop();
            track.source = null;
          }
        });

        this.stopProgressUpdate();
        this.updateProgress();

        // Stop scatter effect if active
        if (this.effects.scatter.active && this.effects.scatter.node) {
          this.effects.scatter.node.stopScatter();
        }
      }

      forceStopAllAudio() {
        logger.log('Force stopping all audio sources');

        // Stop all track sources
        this.tracks.forEach(track => {
          if (track.source) {
            try {
              track.source.stop();
              logger.log(`Force stopped source for track ${track.id}`);
            } catch (e) {
              logger.log(`Track ${track.id} source already stopped`);
            }
            track.source = null;
          }

          // Also disconnect gain nodes to ensure no audio passes through
          if (track.gainNode) {
            track.gainNode.disconnect();
            track.gainNode.connectedToMaster = false;
            logger.log(`Disconnected gain node for track ${track.id}`);
          }
        });

        // Reset playback state
        this.isPlaying = false;
        this.currentTime = 0;
        this.stopProgressUpdate();

        // Force audio context cleanup with more aggressive approach
        if (this.audioContext) {
          try {
            // Suspend audio context immediately
            if (this.audioContext.state === 'running') {
              this.audioContext.suspend();
              logger.log('Audio context suspended during force stop');
            }

            // Create multiple silent buffers to ensure cleanup
            for (let i = 0; i < 3; i++) {
              const silentBuffer = this.audioContext.createBuffer(2, 1, 22050);
              const silentSource = this.audioContext.createBufferSource();
              silentSource.buffer = silentBuffer;
              silentSource.stop();
              logger.log(`Created silent buffer ${i + 1} for cleanup`);
            }
            logger.log('Forced audio context cleanup with multiple silent buffers');
          } catch (e) {
            logger.log('Audio context cleanup failed:', e);
          }
        }

        logger.log('All audio force stopped');
      }

      startProgressUpdate() {
        logger.log('startProgressUpdate called');

        // CRITICAL FIX: Calculate reference point based on current seek position
        // This ensures smooth progress updates after seeking without acceleration
        let startRef = 0;
        if (this.audioContext && this.currentTime > 0) {
          // If we're seeking to a position, calculate the reference point
          startRef = this.audioContext.currentTime - this.currentTime;
        } else {
          // Starting from beginning, use current audio context time as reference
          startRef = this.audioContext ? this.audioContext.currentTime : 0;
        }

        logger.log(`Progress update started with startRef: ${startRef}, currentTime: ${this.currentTime}, duration: ${this.duration}`);
        logger.log(`AudioContext currentTime: ${this.audioContext?.currentTime}`);

        const tick = () => {
          if (!this.isPlaying) {
            logger.log('Progress update stopped: not playing');
            return;
          }

          // CRITICAL: Check if duration is valid before proceeding
          if (this.duration <= 0) {
            logger.log('Progress update stopped: invalid duration (0 or negative)');
            return;
          }

          // Use AudioContext timebase for accuracy on mobile
          if (this.audioContext) {
            // Calculate time based on elapsed time since start reference
            const elapsedTime = this.audioContext.currentTime - startRef;
            const newTime = Math.max(0, elapsedTime);

            // Debug progress calculation
            if (this.currentTime % 5 < 0.1) { // Log every ~5 seconds
              logger.log(`Progress debug: elapsedTime=${elapsedTime.toFixed(2)}, newTime=${newTime.toFixed(2)}, currentTime=${this.currentTime.toFixed(2)}`);
            }

            // Validate the new time to prevent jumping
            if (Math.abs(newTime - this.currentTime) > 0.01) {
              // Additional validation: ensure we're not jumping backwards unless it's a small correction
              if (newTime >= this.currentTime - 0.1) {
                logger.log(`Progress update: currentTime changed from ${this.currentTime} to ${newTime}`);
                this.currentTime = newTime;
              } else {
                logger.warn(`Progress update: skipping backward jump from ${this.currentTime} to ${newTime}`);
              }
            }
          } else {
            this.currentTime += 0.016;
          }

          if (this.currentTime >= this.duration) {
            logger.log('Progress update stopped: reached end');
            this.stop();
            return;
          }

          this.updateProgress();

          // Use requestAnimationFrame for smooth progress updates
          if (this.isPlaying) {
            this.progressInterval = requestAnimationFrame(tick);
          }
        };
        this.progressInterval = requestAnimationFrame(tick);
        logger.log('Progress update animation frame requested');
      }

      stopProgressUpdate() {
        if (this.progressInterval) {
          cancelAnimationFrame(this.progressInterval);
          this.progressInterval = null;
          logger.log('Progress update stopped');
        }
      }

      validateProgressUpdateState() {
        logger.log('=== VALIDATING PROGRESS UPDATE STATE ===');
        logger.log(`isPlaying: ${this.isPlaying}`);
        logger.log(`currentTime: ${this.currentTime}`);
        logger.log(`duration: ${this.duration}`);
        logger.log(`progressInterval: ${this.progressInterval ? 'active' : 'null'}`);
        logger.log(`audioContext state: ${this.audioContext?.state}`);
        logger.log(`audioContext currentTime: ${this.audioContext?.currentTime}`);
        logger.log('=== PROGRESS UPDATE STATE VALIDATION COMPLETE ===');
      }

      resetProgressUpdate() {
        logger.log('=== RESETTING PROGRESS UPDATE ===');

        // Stop current progress update
        this.stopProgressUpdate();

        // Reset current time to 0
        this.currentTime = 0;

        // Update progress bar to show 0%
        this.updateProgress();

        logger.log('Progress update reset complete');
      }

      updateProgress() {
        if (this.duration <= 0) return;

        const percentage = (this.currentTime / this.duration) * 100;
        const clampedPercentage = Math.max(0, Math.min(100, percentage));

        // Update simple progress bar
        const progressFill = document.getElementById('main-progress-fill');
        const progressHandle = document.getElementById('main-progress-handle');

        if (progressFill) {
          // Prevent unnecessary updates that could cause jumping
          const currentWidth = parseFloat(progressFill.style.width) || 0;
          if (Math.abs(currentWidth - clampedPercentage) < 0.1) {
            return; // Skip update if change is too small
          }

          progressFill.style.width = `${clampedPercentage}%`;
          logger.log(`Progress bar updated: ${clampedPercentage.toFixed(1)}%`);
        } else {
          logger.error('Progress fill element not found!');
        }

        if (progressHandle) {
          progressHandle.style.left = `${clampedPercentage}%`;
        } else {
          logger.error('Progress handle element not found!');
        }

        // Update simple time display
        this.updateSimpleTimeDisplay();

        // Update waveform playheads to sync with master progress
        this.updateWaveformPlayheads();

        // Update master waveform with current position
        this.updateMasterWaveformPosition(clampedPercentage);

        logger.log(`Progress updated: ${this.currentTime.toFixed(2)}s / ${this.duration.toFixed(2)}s (${clampedPercentage.toFixed(1)}%)`);
      }

      updateSimpleTimeDisplay() {
        const currentMinutes = Math.floor(this.currentTime / 60);
        const currentSeconds = Math.floor(this.currentTime % 60);

        // Update current time display only
        const currentTimeElement = document.getElementById('currentTime');
        if (currentTimeElement) {
          currentTimeElement.textContent = `${currentMinutes}:${currentSeconds.toString().padStart(2, '0')}`;
          logger.log(`Time display updated: ${currentMinutes}:${currentSeconds.toString().padStart(2, '0')}`);
        } else {
          logger.error('Current time element not found!');
        }
      }

      updateDuration() {
        // Only update duration if there are downloaded tracks
        const downloadedTracks = this.tracks.filter(track => track.isDownloaded && track.audioBuffer);
        logger.log('updateDuration called, downloaded tracks:', downloadedTracks.length);
        logger.log('Track details:', downloadedTracks.map(t => ({
          id: t.id,
          name: t.name,
          isDownloaded: t.isDownloaded,
          hasAudioBuffer: !!t.audioBuffer,
          bufferDuration: t.audioBuffer?.duration
        })));

        if (downloadedTracks.length > 0) {
          this.duration = Math.max(...downloadedTracks.map(t => t.audioBuffer.duration));
          const totalMinutes = Math.floor(this.duration / 60);
          const totalSeconds = Math.floor(this.duration % 60);

          logger.log(`Duration updated: ${this.duration.toFixed(2)}s (${totalMinutes}:${totalSeconds.toString().padStart(2, '0')})`);

          // Log all track durations for debugging
          this.tracks.forEach(track => {
            if (track.isDownloaded && track.audioBuffer) {
              logger.log(`Track ${track.id} duration: ${track.audioBuffer.duration}s`);
            }
          });

        } else {
          this.duration = 0;
          logger.log('No downloaded tracks available for duration calculation');
        }
      }



      seek(event) {
        const rect = event.currentTarget.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const percentage = x / rect.width;
        const seekTime = percentage * this.duration;
        logger.log(`Main progress bar seek: x=${x}, width=${rect.width}, percentage=${(percentage*100).toFixed(1)}%, time=${seekTime.toFixed(2)}s`);
        logger.log(`Current time before seek: ${this.currentTime}s, duration: ${this.duration}s`);
        this.seekToTime(seekTime);
      }

      updateWaveformPlayheads() {
        if (this.duration > 0) {
          const percentage = (this.currentTime / this.duration) * 100;
          this.tracks.forEach(track => {
            const playhead = track.element.querySelector('.playhead');
            if (playhead) {
              playhead.style.left = `${percentage}%`;
            }
          });
        }
      }

      // Keyboard shortcut helper methods
      skipTime(seconds) {
        const newTime = Math.max(0, Math.min(this.currentTime + seconds, this.duration));
        this.seekToTime(newTime);
      }

      addMark() {
        const mark = {
          time: this.currentTime,
          label: `Mark ${this.marks.length + 1}`,
          timestamp: Date.now()
        };
        this.marks.push(mark);
        this.marks.sort((a, b) => a.time - b.time); // Keep marks sorted by time
        logger.log(`Added mark at ${this.formatTime(mark.time)}: ${mark.label}`);
        this.displayMarks();
      }

      jumpToPreviousMark() {
        if (this.marks.length === 0) return;

        const currentMarkIndex = this.marks.findIndex(mark => mark.time > this.currentTime);
        let targetMark;

        if (currentMarkIndex === -1) {
          // Current time is after all marks, go to last mark
          targetMark = this.marks[this.marks.length - 1];
        } else if (currentMarkIndex === 0) {
          // Current time is before first mark, go to first mark
          targetMark = this.marks[0];
        } else {
          // Go to previous mark
          targetMark = this.marks[currentMarkIndex - 1];
        }

        if (targetMark) {
          this.seekToTime(targetMark.time);
          logger.log(`Jumped to previous mark: ${targetMark.label} at ${this.formatTime(targetMark.time)}`);
        }
      }

      jumpToNextMark() {
        if (this.marks.length === 0) return;

        const currentMarkIndex = this.marks.findIndex(mark => mark.time > this.currentTime);
        let targetMark;

        if (currentMarkIndex === -1) {
          // Current time is after all marks, go to first mark
          targetMark = this.marks[0];
        } else if (currentMarkIndex >= this.marks.length) {
          // Current time is after last mark, go to first mark
          targetMark = this.marks[0];
        } else {
          // Go to next mark
          targetMark = this.marks[currentMarkIndex];
        }

        if (targetMark) {
          this.seekToTime(targetMark.time);
          logger.log(`Jumped to next mark: ${targetMark.label} at ${this.formatTime(targetMark.time)}`);
        }
      }

      displayMarks() {
        // Create or update marks display
        let marksContainer = document.getElementById('marksContainer');
        if (!marksContainer) {
          marksContainer = document.createElement('div');
          marksContainer.id = 'marksContainer';
          marksContainer.className = 'marks-container';
          document.querySelector('.bottom-controls').appendChild(marksContainer);
        }

        marksContainer.innerHTML = '';
        if (this.marks.length > 0) {
          const marksList = document.createElement('div');
          marksList.className = 'marks-list';
          marksList.innerHTML = '<strong>Marks:</strong> ';

          this.marks.forEach((mark, index) => {
            const markSpan = document.createElement('span');
            markSpan.className = 'mark-item';
            markSpan.textContent = `${mark.label} (${this.formatTime(mark.time)})`;
            markSpan.addEventListener('click', () => this.seekToTime(mark.time));
            markSpan.title = `Click to jump to ${mark.label}`;
            marksList.appendChild(markSpan);
            if (index < this.marks.length - 1) {
              marksList.appendChild(document.createTextNode(' • '));
            }
          });

          marksContainer.appendChild(marksList);
        }
      }

      formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${minutes}:${secs.toString().padStart(2, '0')}`;
      }

      // Effects methods
      async toggleEffect(effectType) {
        const effect = this.effects[effectType];
        const button = document.getElementById(`${effectType}Btn`);

        if (!button) {
          logger.error(`Effect button not found for ${effectType}`);
          return;
        }

        if (effect.active) {
          logger.log(`Disabling ${effectType} effect`);
          this.disableEffect(effectType);
          button.classList.remove('active');
        } else {
          logger.log(`Enabling ${effectType} effect`);
          await this.enableEffect(effectType);
          if (this.effects[effectType].active) {
            button.classList.add('active');
          } else {
            logger.log(`Effect ${effectType} was not enabled, keeping button inactive`);
          }
        }

        // Debug: log effect state
        logger.log(`${effectType} effect active:`, this.effects[effectType].active);
        logger.log(`${effectType} effect node:`, this.effects[effectType].node);
      }

      async enableEffect(effectType) {
        if (!this.audioContext) {
          logger.log(`Cannot enable effect ${effectType}: audio context not available`);
          return;
        }

        if (this.audioContext.state !== 'running') {
          logger.log(`Cannot enable effect ${effectType}: audio context not running (state: ${this.audioContext.state})`);
          return;
        }

        const effect = this.effects[effectType];
        if (effect.active) {
          logger.log(`Effect ${effectType} is already active`);
          return;
        }

        // Check if we have tracks loaded
        if (this.tracks.length === 0) {
          logger.log(`Cannot enable effect ${effectType}: no tracks loaded`);
          return;
        }

        try {
          effect.active = true;
          effect.node = this.createEffectNode(effectType);

          if (effect.node) {
                      // Insert effect into audio chain
          await this.insertEffectIntoChain(effectType);

            // Ensure tracks are properly connected to master gain
            this.ensureTracksConnectedToMaster();

            // Validate the effect chain
            this.validateEffectChain();

            logger.log(`${effectType} effect enabled successfully`);
          } else {
            logger.error(`Failed to create effect node for ${effectType}`);
            effect.active = false;
          }
        } catch (error) {
          logger.error(`Failed to enable effect ${effectType}:`, error);
          effect.active = false;
        }
      }

            disableEffect(effectType) {
        const effect = this.effects[effectType];
        if (!effect.active) return;

        effect.active = false;

        // Remove effect from audio chain
        this.removeEffectFromChain(effectType);

        if (effect.node) {
          // Properly disconnect all nodes based on effect type
          this.disconnectEffectNodes(effectType, effect.node);
          effect.node = null;
        }

        logger.log(`${effectType} effect disabled`);
      }

      disconnectEffectNodes(effectType, effectNode) {
        switch (effectType) {
          case 'scatter':
            if (effectNode.main) effectNode.main.disconnect();
            if (effectNode.gain) effectNode.gain.disconnect();
            break;
          case 'pitch':
            if (effectNode.delay) effectNode.delay.disconnect();
            if (effectNode.feedback) effectNode.feedback.disconnect();
            if (effectNode.lfo) effectNode.lfo.stop();
            if (effectNode.lfoGain) effectNode.lfoGain.disconnect();
            if (effectNode.main) effectNode.main.disconnect();
            break;
          case 'ringmod':
            if (effectNode.waveShaper) effectNode.waveShaper.disconnect();
            if (effectNode.filter) effectNode.filter.disconnect();
            if (effectNode.gain) effectNode.gain.disconnect();
            if (effectNode.main) effectNode.main.disconnect();
            break;
          case 'noise':
            if (effectNode.noise) effectNode.noise.disconnect();
            if (effectNode.flanger) effectNode.flanger.disconnect();
            if (effectNode.distortion) effectNode.distortion.disconnect();
            if (effectNode.gain) effectNode.gain.disconnect();
            if (effectNode.main) effectNode.main.disconnect();
            break;
        }
      }

              /**
         * 🎛️ EFFECTS SYSTEM - Audio Processing Chain
         *
         * This system manages all audio effects and their connections to the master audio chain.
         * Each effect processes the master mix and applies its unique audio transformation.
         *
         * Available Effects:
         * - 🎭 Noise Flanger: White noise + distortion + flanging
         *
         * All effects are controlled by the "Krazy" parameter slider (0-100)
         * which dynamically adjusts effect intensity and parameters in real-time.
         */
      createEffectNode(effectType) {
        switch (effectType) {
                  case 'noise':
          return this.createNoiseNode();
          default:
            return null;
        }
      }



                                          /**
       * 🌀 SCATTER EFFECT - Position Jumping Chaos
       *
       * This effect creates random position jumping in the track, making the playback
       * scatter around different positions like a broken record player on steroids.
       *
       * How it works:
       * - Randomly jumps to different positions in the track
       * - Krazy parameter controls jump length (100ms to 2 seconds) and frequency
       * - Creates unpredictable, chaotic playback patterns
       * - Perfect for glitch music and experimental audio
       *
       * Audio Chain: masterGain -> input -> scatter -> gain -> destination
       * Krazy Control: Jump length (100ms-2s), Jump interval (500ms-2s)
       */

      createReverseBuffer(originalBuffer) {
        // Create a reversed version of the audio buffer
        const reversedBuffer = this.audioContext.createBuffer(
          originalBuffer.numberOfChannels,
          originalBuffer.length,
          originalBuffer.sampleRate
        );

        for (let channel = 0; channel < originalBuffer.numberOfChannels; channel++) {
          const originalData = originalBuffer.getChannelData(channel);
          const reversedData = reversedBuffer.getChannelData(channel);

          for (let i = 0; i < originalBuffer.length; i++) {
            reversedData[i] = originalData[originalBuffer.length - 1 - i];
          }
        }

        return reversedBuffer;
      }

                  /**
       * 🎵 PITCH SHIFT EFFECT - LFO Modulated Pitch Shifting
       *
       * This effect creates dynamic pitch shifting using delay lines and LFO modulation.
       * The pitch of the audio constantly shifts up and down, creating a warbling,
       * underwater-like effect that's perfect for psychedelic and experimental music.
       *
       * How it works:
       * - Uses delay lines with feedback to create pitch shifting
       * - LFO modulates the delay time, causing pitch variations
       * - Krazy parameter controls delay time, LFO frequency, and modulation depth
       * - Creates smooth, continuous pitch variations
       *
       * Audio Chain: masterGain -> input -> (original + delayed) -> mixer -> output
       * Krazy Control: Delay time (5-55ms), LFO freq (0.5-15.5Hz), Modulation depth (1-51ms), Feedback (30-100%)
       */

                                    /**
       * ⚡ BITCRUSHER EFFECT - Digital Distortion & Bit Reduction
       *
       * This effect creates aggressive digital distortion by reducing the bit depth
       * of the audio signal, simulating old digital hardware and creating harsh,
       * lo-fi textures perfect for industrial, noise, and experimental music.
       *
       * How it works:
       * - Reduces bit depth from 8-bit down to 1-bit (heavy crushing)
       * - Applies wave shaping for additional distortion
       * - Low-pass filter cuts high frequencies for authentic lo-fi sound
       * - Krazy parameter controls bit depth and filter frequency
       *
       * Audio Chain: masterGain -> input -> waveShaper -> filter -> gain -> destination
       * Krazy Control: Bit depth (8-bit to 1-bit), Filter frequency (4kHz to 2kHz)
       */

      createNoiseNode() {
        /**
         * 🎭 NOISE FLANGER EFFECT - White Noise + Distortion + Flanging
         *
         * This is a complex multi-layered effect that combines white noise generation,
         * heavy distortion, and flanging to create a chaotic, industrial soundscape.
         * Perfect for noise music, industrial, and experimental audio.
         *
         * How it works:
         * - Generates white noise using multiple oscillators (sawtooth, triangle, square)
         * - Mixes noise with master audio
         * - Applies heavy distortion to the mixed signal
         * - Adds flanging with LFO-controlled delay time and feedback
         * - Krazy parameter allows extreme values for maximum chaos
         *
         * Audio Chain: (main + noise) -> distortion -> flanger -> destination
         * Krazy Control: Noise mix (0-100%), Distortion intensity (1-100x), Flanger depth (0-100ms), Feedback (0-100%)
         */
        // Create input mixer to combine master audio with noise
        const inputMixer = this.audioContext.createGain();
        inputMixer.gain.value = 1;

        // Create white noise generator using multiple oscillators for true noise
        const noise = this.audioContext.createOscillator();
        noise.type = 'sawtooth';
        noise.frequency.value = 50; // Very low frequency for more noise-like sound

        // Create additional noise layers for more complex noise
        const noise2 = this.audioContext.createOscillator();
        noise2.type = 'triangle';
        noise2.frequency.value = 75;

        const noise3 = this.audioContext.createOscillator();
        noise3.type = 'square';
        noise3.frequency.value = 25;

        // Create gain node for noise mix (controlled by Krazy)
        const noiseGain = this.audioContext.createGain();
        noiseGain.gain.value = 0.1; // Start with 10% noise mix

        // Create distortion for heavy effect on mixed signal
        const distortion = this.audioContext.createWaveShaper();
        const curve = new Float32Array(4096);
        for (let i = 0; i < 4096; i++) {
          const x = (i * 2) / 4096 - 1;
          curve[i] = Math.sign(x) * (1 - Math.exp(-Math.abs(x) * 5)); // Start with moderate distortion
        }
        distortion.curve = curve;
        distortion.oversample = '4x';

        // Create flanger effect with feedback
        const flanger = this.audioContext.createDelay(0.1); // 100ms max delay
        flanger.delayTime.value = 0.01; // Start with 10ms delay

        // Create feedback loop for flanger
        const flangerFeedback = this.audioContext.createGain();
        flangerFeedback.gain.value = 0.3; // Start with 30% feedback

        // Create LFO for flanger time modulation
        const lfo = this.audioContext.createOscillator();
        lfo.type = 'sine';
        lfo.frequency.value = 0.5; // Start with 0.5Hz

        // Create LFO gain for flanger depth
        const lfoGain = this.audioContext.createGain();
        lfoGain.gain.value = 0.005; // Start with 5ms modulation depth

        // Connect LFO to flanger delay time
        lfo.connect(lfoGain);
        lfoGain.connect(flanger.delayTime);

        // Connect flanger feedback loop
        flanger.connect(flangerFeedback);
        flangerFeedback.connect(flanger);

        // Connect noise layers to noise gain
        noise.connect(noiseGain);
        noise2.connect(noiseGain);
        noise3.connect(noiseGain);

        // Start oscillators
        noise.start();
        noise2.start();
        noise3.start();
        lfo.start();

        // Set krazy level function - allows extreme values for maximum chaos
        const setKrazyLevel = (level) => {
          const krazyLevel = Math.max(0, Math.min(100, level));

          // Adjust noise mix based on krazy level (0% to 100%)
          noiseGain.gain.value = krazyLevel / 100; // 0.0 to 1.0 (0% to 100%)

          // Adjust distortion intensity based on krazy level (1x to 100x)
          const distortionIntensity = 1 + (krazyLevel * 0.99); // 1 to 100
          for (let i = 0; i < 4096; i++) {
            const x = (i * 2) / 4096 - 1;
            curve[i] = Math.sign(x) * (1 - Math.exp(-Math.abs(x) * distortionIntensity));
          }
          distortion.curve = curve;

          // Adjust flanger depth based on krazy level (0ms to 100ms)
          lfoGain.gain.value = krazyLevel / 1000; // 0.0 to 0.1 (0ms to 100ms)

          // Adjust flanger feedback based on krazy level (0% to 100%)
          flangerFeedback.gain.value = krazyLevel / 100; // 0.0 to 1.0 (0% to 100%)

          // Adjust LFO frequency based on krazy level (0.1Hz to 10Hz)
          lfo.frequency.value = 0.1 + (krazyLevel * 0.099); // 0.1 to 10 Hz

          logger.log(`Noise Flanger Krazy: noiseMix=${(noiseGain.gain.value * 100).toFixed(0)}%, distortionIntensity=${distortionIntensity.toFixed(1)}x, flangerDepth=${(lfoGain.gain.value * 1000).toFixed(0)}ms, feedback=${(flangerFeedback.gain.value * 100).toFixed(0)}%, lfoFreq=${lfo.frequency.value.toFixed(1)}Hz`);
        };

        return {
          main: flanger, // Main output is the flanger (final stage)
          input: inputMixer, // Input node for master audio
          noise: noise,
          noise2: noise2,
          noise3: noise3,
          flanger: flanger,
          distortion: distortion,
          noiseGain: noiseGain,
          flangerFeedback: flangerFeedback,
          lfo: lfo,
          lfoGain: lfoGain,
          setKrazyLevel
        };
      }

      async insertEffectIntoChain(effectType) {
        const effect = this.effects[effectType];
        if (!effect || !effect.node) {
          logger.log(`Cannot insert effect ${effectType}: effect or node not found`);
          return;
        }

        // Ensure audio context is running
        if (this.audioContext.state !== 'running') {
          logger.log(`Cannot insert effect ${effectType}: audio context not running, attempting to resume...`);
          try {
            await this.audioContext.resume();
            logger.log(`Audio context resumed, state: ${this.audioContext.state}`);
          } catch (resumeError) {
            logger.error(`Failed to resume audio context:`, resumeError);
            return;
          }
        }

        try {
          logger.log(`=== INSERTING EFFECT ${effectType.toUpperCase()} ===`);
          logger.log(`Effect node:`, effect.node);
          logger.log(`Audio context state: ${this.audioContext.state}`);
          logger.log(`Master gain connections:`, this.masterGain.numberOfOutputs);

          // Disconnect masterGain from destination temporarily
          this.masterGain.disconnect();
          logger.log(`Master gain disconnected from destination`);

          if (effectType === 'noise') {
            // Noise Flanger: (main + noise) -> distortion -> flanger -> destination
            if (effect.node.main && effect.node.input && effect.node.distortion && effect.node.flanger) {
              // Connect master audio to input mixer
              this.masterGain.connect(effect.node.input);

              // Connect noise to input mixer (mixing with master audio)
              effect.node.noiseGain.connect(effect.node.input);

              // Connect input mixer to distortion
              effect.node.input.connect(effect.node.distortion);

              // Connect distortion to flanger
              effect.node.distortion.connect(effect.node.flanger);

              // Connect flanger (final stage) to destination
              effect.node.main.connect(this.audioContext.destination);

              logger.log(`✅ Noise Flanger effect connected: (main + noise) -> distortion -> flanger -> destination`);
            } else {
              logger.error('❌ Noise Flanger node missing required components');
              logger.error('Available nodes:', Object.keys(effect.node));
            }
          }

          logger.log(`✅ Effect ${effectType} successfully inserted into audio chain`);
          logger.log(`=== EFFECT ${effectType.toUpperCase()} INSERTION COMPLETE ===`);
        } catch (error) {
          logger.error(`❌ Failed to insert effect ${effectType}:`, error);
          // Restore normal audio chain on error
          this.restoreNormalAudioChain();
        }
      }

      restoreNormalAudioChain() {
        try {
          logger.log('Restoring normal audio chain after effect error');

          // Disconnect master gain from any effects
          this.masterGain.disconnect();

          // Disconnect stereo panner from destination
          if (this.stereoPanner) {
            this.stereoPanner.disconnect();
          }

          // Restore normal chain: masterGain -> stereoPanner -> destination
          this.masterGain.connect(this.stereoPanner);
          this.stereoPanner.connect(this.audioContext.destination);

          logger.log('Normal audio chain restored: masterGain -> stereoPanner -> destination');
        } catch (error) {
          logger.error('Failed to restore normal audio chain:', error);
        }
      }

      ensureTracksConnectedToMaster() {
        if (!this.audioContext || this.audioContext.state !== 'running') {
          logger.log('Cannot ensure tracks connected: audio context not ready');
          return;
        }

        // Ensure all tracks are connected to master gain
        this.tracks.forEach(track => {
          if (track.gainNode && !track.gainNode.connectedToMaster) {
            try {
              track.gainNode.connect(this.masterGain);
              track.gainNode.connectedToMaster = true;
              logger.log(`Track ${track.id} gain node connected to master`);
            } catch (error) {
              logger.error(`Failed to connect track ${track.id} to master:`, error);
            }
          }
        });

        // Check if we have active effects
        const hasActiveEffects = Object.values(this.effects).some(effect => effect.active);
        logger.log(`Active effects: ${hasActiveEffects ? 'yes' : 'no'}`);

        if (!hasActiveEffects) {
          // No effects active, ensure normal audio chain: masterGain -> stereoPanner -> destination
          try {
            this.masterGain.disconnect();
            this.masterGain.connect(this.stereoPanner);
            this.stereoPanner.connect(this.audioContext.destination);
            logger.log('Audio chain restored to normal: masterGain -> stereoPanner -> destination');
          } catch (error) {
            logger.error('Failed to restore normal audio chain:', error);
          }
        } else {
          logger.log('Effects are active, audio chain managed by effects');
        }
      }

      removeEffectFromChain(effectType) {
        const effect = this.effects[effectType];
        if (!effect || !effect.node) return;

                // Disconnect effect from audio chain
        if (effectType === 'noise') {
          // Disconnect all components of the Noise Flanger
          if (effect.node.main) effect.node.main.disconnect();
          if (effect.node.input) effect.node.input.disconnect();
          if (effect.node.flanger) effect.node.flanger.disconnect();
          if (effect.node.distortion) effect.node.distortion.disconnect();
          if (effect.node.noiseGain) effect.node.noiseGain.disconnect();
          if (effect.node.flangerFeedback) effect.node.flangerFeedback.disconnect();

          // Stop oscillators
          if (effect.node.noise && effect.node.noise.stop) effect.node.noise.stop();
          if (effect.node.noise2 && effect.node.noise2.stop) effect.node.noise2.stop();
          if (effect.node.noise3 && effect.node.noise3.stop) effect.node.noise3.stop();
          if (effect.node.lfo && effect.node.lfo.stop) effect.node.lfo.stop();
        }

        // Restore normal audio chain: masterGain -> stereoPanner -> destination
        this.masterGain.disconnect();
        this.masterGain.connect(this.stereoPanner);
        this.stereoPanner.connect(this.audioContext.destination);

        // Ensure tracks are properly connected after effect removal
        this.ensureTracksConnectedToMaster();

        // Validate the effect chain after removal
        this.validateEffectChain();

        logger.log(`Effect ${effectType} removed from audio chain`);
      }

      validateEffectChain() {
        logger.log('=== VALIDATING EFFECT CHAIN ===');

        // Check if master gain is connected to the right destination
        const masterGainInputs = this.masterGain.numberOfInputs;
        const masterGainOutputs = this.masterGain.numberOfOutputs;
        logger.log(`Master gain: ${masterGainInputs} inputs, ${masterGainOutputs} outputs`);

        // Check if we have active effects
        const activeEffects = Object.entries(this.effects).filter(([type, effect]) => effect.active);
        logger.log(`Active effects: ${activeEffects.length}`);

        activeEffects.forEach(([type, effect]) => {
          if (effect.node) {
            logger.log(`Effect ${type}: node exists, checking connections`);
            // Log the effect node structure
            logger.log(`Effect ${type} node:`, effect.node);
          } else {
            logger.log(`Effect ${type}: no node found`);
          }
        });

        // Check if master gain is connected to destination through effects or normal chain
        const hasActiveEffects = activeEffects.length > 0;
        if (hasActiveEffects) {
          logger.log('Effects are active - master gain should be connected to effect nodes');
        } else {
          logger.log('No effects active - master gain should be connected to stereo panner');
        }

        logger.log('=== EFFECT CHAIN VALIDATION COMPLETE ===');
      }

      // Simple effect test method
      testEffect(effectType) {
        const effect = this.effects[effectType];
        if (effect && effect.node) {
          logger.log(`✅ Effect ${effectType} is working:`, effect.node);
          return true;
        } else {
          logger.log(`❌ Effect ${effectType} is not working:`, effect);
          return false;
        }
      }

      // iOS Audio Test Function
      testIOSAudio() {
        logger.log('=== TESTING iOS AUDIO ===');

        if (!this.audioContext) {
          logger.error('❌ No audio context available');
          return false;
        }

        logger.log(`Audio Context State: ${this.audioContext.state}`);
        logger.log(`Audio Context Sample Rate: ${this.audioContext.sampleRate}`);
        logger.log(`Master Gain Value: ${this.masterGain?.gain.value}`);
        logger.log(`Destination Muted: ${this.audioContext.destination.muted}`);

        // Create a simple test tone
        try {
          const oscillator = this.audioContext.createOscillator();
          const gainNode = this.audioContext.createGain();

          oscillator.type = 'sine';
          oscillator.frequency.value = 440; // A4 note
          gainNode.gain.value = 0.1; // Low volume for test

          oscillator.connect(gainNode);
          gainNode.connect(this.audioContext.destination);

          oscillator.start();
          setTimeout(() => {
            oscillator.stop();
            logger.log('✅ iOS Audio Test: Test tone played successfully');
          }, 500);

          return true;
        } catch (error) {
          logger.error('❌ iOS Audio Test failed:', error);
          return false;
        }
      }


    }

    // Initialize player when page loads
    document.addEventListener('DOMContentLoaded', () => {
      window.player = new MultitrackPlayer();
    });

            // iOS Audio Unlock System - Add event listeners for user interaction
        function setupIOSAudioUnlock() {
          const unlockAudio = () => {
            logger.log('iOS Audio Unlock: User interaction detected, attempting to unlock audio...');

            // Try to unlock any existing audio context
            if (window.player && window.player.audioContext) {
              const audioCtx = window.player.audioContext;
              if (audioCtx.state === 'suspended') {
                audioCtx.resume().then(() => {
                  logger.log('iOS Audio Unlock: Audio context unlocked via user interaction!');
                  // Show success message
                  const unlockMsg = document.createElement('div');
                  unlockMsg.style.cssText = 'position:fixed;top:20px;right:20px;background:#4CAF50;color:white;padding:10px;border-radius:5px;z-index:9999;';
                  unlockMsg.textContent = '🎵 Audio unlocked!';
                  document.body.appendChild(unlockMsg);
                  setTimeout(() => unlockMsg.remove(), 3000);
                }).catch(err => {
                  logger.error('iOS Audio Unlock: Failed to unlock audio context:', err);
                });
              }
            }
          };

          // Add event listeners for iOS audio unlock
          document.body.addEventListener('click', unlockAudio, { once: false });
          document.body.addEventListener('touchstart', unlockAudio, { once: false });
          document.body.addEventListener('touchend', unlockAudio, { once: false });

          // Add keyboard shortcuts for iOS audio unlock
          document.addEventListener('keydown', (e) => {
            // Common shortcuts: space (play/pause), arrow keys, etc.
            if ([' ', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Enter'].includes(e.key)) {
              unlockAudio();
            }
          });

          logger.log('iOS Audio Unlock: Event listeners set up for user interaction and shortcuts');
        }

    // Set up iOS audio unlock when page loads
    document.addEventListener('DOMContentLoaded', setupIOSAudioUnlock);
  </script>
</body>

</html>

